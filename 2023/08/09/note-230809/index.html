<!DOCTYPE HTML>
<html lang="en">
<head>

  <meta charset="utf-8">
  
    <title>
      note_230809 | Jutta&#39;s Blog</title>
  <meta name="author" content="Jutta">
  
  <meta name="description" content="用ChatGPT辅助写的一些笔记">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="note_230809"/>
  <meta property="og:site_name" content="Jutta&#39;s Blog"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/%20favicon.png">
        
                  
<link rel="stylesheet" href="/css/style.css">

                    <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
                    

<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <!-- 这里是改动过的 -->
    <!-- 插入获取IP地址和浏览器语言的JavaScript代码 -->
    <!-- <script>
      fetch('https://api.ipify.org?format=json')
        .then(response => response.json())
        .then(data => {
          const ipAddress = data.ip;
          document.getElementById('ipAddress').textContent = ipAddress;
        })
        .catch(error => console.error(error));

      const browserLanguage = navigator.language;
      document.getElementById('browserLanguage').textContent = browserLanguage;
    </script> -->


    <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">
      Jutta&#39;s Blog
    </a></h1>
  <h2><a href="/">
      
        勿以浮沙築高台
          
    </a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">
          Home
        </a></li>
      
      <li><a href="/archives">
          Archives
        </a></li>
      
      <li><a href="/jutta">
          About me
        </a></li>
      
        <!-- <li><a href="https://github.com/test" target="_blank" rel="noopener noreferrer">GitHub</a></li> -->
        <!-- <li><a href="https://test.medium.com" target="_blank" rel="noopener noreferrer">Medium</a></li> -->
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
    <div id="content" class="inner">

      <div id="main-col" class="alignleft">
        <div id="wrapper"><article id="post-note-230809" class="h-entry post" itemprop="blogPost" itemscope
  itemtype="https://schema.org/BlogPosting">
  
        <div class="post-content">
          <header>
            
              <div class="icon"></div>
              <time class="dt-published" datetime="2023-08-08T16:00:00.000Z"><a
                  href="/2023/08/09/note-230809/">
                  2023-08-09
                </a></time>
              
                
  
    <h1 class="p-name title" itemprop="headline name">note_230809</h1>
  

          </header>
          <div class="e-content entry" itemprop="articleBody">
            
                  <p>用ChatGPT辅助写的一些笔记</p>
<span id="more"></span>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC是“Model-View-Controller”的缩写，它是一种常用的软件开发设计模式，用于将应用程序的关注点分离为三个相互连接的组件：</p>
<ol>
<li><p>模型（Model）：<br>模型代表应用程序的数据和业务逻辑。它处理数据的存储、检索和操作。模型封装了应用程序的数据和状态，并提供与之交互的方法。模型组件不直接与视图（用户界面）或控制器（用户输入）进行交互。</p>
</li>
<li><p>视图（View）：<br>视图代表应用程序的用户界面（UI）。它负责向用户显示数据，并呈现模型提供的信息。视图是被动的，不包含任何应用程序逻辑。它只关注如何将数据呈现给用户，以及如何显示用户的交互。</p>
</li>
<li><p>控制器（Controller）：<br>控制器充当模型和视图之间的中间层。它处理用户输入，对其进行处理，并相应地更新模型。当模型发生变化时，控制器会更新视图以反映这些变化。它负责管理模型和视图之间的数据流，根据用户的操作进行决策，并控制应用程序的整体行为。</p>
</li>
</ol>
<p>使用MVC模式的主要优势是它促进了关注点的分离，使代码库更易于维护和扩展。对用户界面（视图）的更改不会影响底层数据或业务逻辑（模型），反之亦然。这种模块化的方法增强了代码的可重用性，并促进了更有组织的开发过程。</p>
<p>MVC在各种编程语言和框架中广泛使用，用于构建Web应用程序、桌面应用程序和移动应用程序。一些使用MVC模式的流行框架包括Ruby on Rails（用于Ruby）、Django（用于Python）、ASP.NET MVC（用于.NET）和Spring（用于Java）。</p>
<h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><p>JavaBean是Java语言中的一个编程规范，用于创建可重用组件的标准方式。它是一种普通的Java类，遵循一组特定的约定和规则，以便在Java开发中使用它们更加方便。</p>
<p>JavaBean必须满足以下规范：</p>
<ol>
<li><p>公共类：JavaBean必须是一个公共类，即类声明使用<code>public</code>修饰符。</p>
</li>
<li><p>无参构造函数：JavaBean必须有一个无参数的公共构造函数（默认构造函数），这样可以通过该构造函数创建JavaBean的实例。</p>
</li>
<li><p>属性访问器（Getter和Setter方法）：JavaBean应该具有用于访问其属性的Getter和Setter方法。Getter方法用于获取属性的值，Setter方法用于设置属性的值。这样可以提供对JavaBean内部属性的封装和访问。</p>
</li>
<li><p>可序列化：JavaBean可以实现<code>java.io.Serializable</code>接口，从而允许其实例在网络上传输或保存在文件中。</p>
</li>
</ol>
<p>使用JavaBean的主要目的是促进代码的重用和提高代码的可读性。通过遵循JavaBean规范，可以创建符合标准的、易于使用的组件，这些组件可以在各种Java应用程序中使用，并且与其他JavaBean组件更加兼容。</p>
<p>例如，以下是一个简单的JavaBean示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter和Setter方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>Person</code>类符合JavaBean规范，具有公共类、无参构造函数和Getter&#x2F;Setter方法。同时，它还实现了<code>Serializable</code>接口，使得<code>Person</code>对象可以在网络上传输或进行序列化操作。</p>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>Servlet是Java编程语言的一个规范，用于在Web服务器上处理客户端请求和生成动态内容的组件。它是Java企业版（Java EE）中的核心技术之一，也可以在Java标准版（Java SE）中使用。</p>
<p>Servlet的主要目的是处理来自Web浏览器或其他HTTP客户端的请求，并根据这些请求生成动态的HTML内容。Servlet扮演了Web应用程序的控制器角色，可以接受HTTP请求并产生HTTP响应。</p>
<p>Servlet遵循以下规范：</p>
<ol>
<li><p>继承规范：一个Servlet类必须继承自<code>javax.servlet.http.HttpServlet</code>类或实现<code>javax.servlet.Servlet</code>接口。</p>
</li>
<li><p>URL映射：在Web应用程序的配置文件（通常是web.xml或使用注解）中，将Servlet映射到特定的URL模式，以便在接收到匹配的HTTP请求时调用相应的Servlet。</p>
</li>
<li><p>生命周期方法：Servlet具有一组生命周期方法，这些方法在Servlet的生命周期中被调用，包括初始化（init）、请求处理（service）和销毁（destroy）等阶段。</p>
</li>
<li><p>请求和响应处理：Servlet使用<code>HttpServletRequest</code>对象来接收HTTP请求数据，使用<code>HttpServletResponse</code>对象生成HTTP响应数据。通过这些对象，可以获取请求参数、处理请求数据，并生成HTML或其他内容作为响应发送回客户端。</p>
</li>
</ol>
<p>Servlet通常用于处理表单提交、登录认证、数据查询、数据保存等各种Web应用程序的业务逻辑。它们与Web容器（如Tomcat、Jetty等）紧密结合，Web容器负责管理Servlet的生命周期、多线程处理、请求分发等任务。</p>
<p>以下是一个简单的Servlet示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;&lt;html&gt;&lt;body&gt;Hello, World!&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>MyServlet</code>继承自<code>HttpServlet</code>，覆盖了<code>doGet</code>方法用于处理HTTP GET请求。当客户端发出HTTP GET请求并匹配到映射到<code>MyServlet</code>的URL模式时，<code>doGet</code>方法将会被调用，并向客户端发送”Hello, World!”的响应。</p>
<h2 id="Spring和Spring-Boot"><a href="#Spring和Spring-Boot" class="headerlink" title="Spring和Spring Boot"></a>Spring和Spring Boot</h2><p>Spring和Spring Boot都是Java平台上非常流行的开源框架，用于构建企业级应用程序。它们之间有一些区别，下面对它们进行简要的介绍：</p>
<h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring:"></a>Spring:</h4><p>Spring是一个轻量级的、模块化的Java开发框架，由Rod Johnson在2003年创建。它提供了大量的功能和库，用于解决企业级应用程序开发中的各种问题，如依赖注入（DI）、面向切面编程（AOP）、事务管理、数据访问、MVC框架等。Spring的目标是通过松耦合和可扩展的设计，提高Java应用程序的可维护性和可测试性。</p>
<p>Spring的特点：</p>
<ul>
<li>提供强大的IoC（控制反转）和DI（依赖注入）容器，使得对象的创建和管理更加灵活和易于测试。</li>
<li>AOP（面向切面编程）支持，允许在应用程序中解耦横切关注点（如日志记录、安全等）。</li>
<li>支持各种数据访问技术，包括JDBC、ORM（对象关系映射）框架（如Hibernate、JPA等）。</li>
<li>提供了Spring MVC框架，用于构建基于MVC模式的Web应用程序。</li>
</ul>
<h4 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot:"></a>Spring Boot:</h4><p>Spring Boot是由Pivotal团队于2014年推出的Spring项目的子项目。它是一个用于快速构建独立、生产级别的Spring应用程序的框架。Spring Boot旨在简化Spring应用程序的配置和部署，从而加快开发过程。它内置了许多常用的Spring组件和第三方库，并通过自动配置和约定优于配置的原则，使得开发者可以快速启动项目，并专注于业务逻辑的实现。</p>
<p>Spring Boot的特点：</p>
<ul>
<li>简化配置：Spring Boot自动配置大部分常用的Spring功能，减少了配置文件的编写工作。</li>
<li>内嵌服务器：Spring Boot可以内嵌Tomcat、Jetty或Undertow等Web服务器，使得应用程序可以直接以可执行的JAR包形式运行。</li>
<li>自动装配：Spring Boot根据项目的依赖关系自动装配各种组件，无需手动配置。</li>
<li>管理工具：Spring Boot提供了一组管理工具，用于监控和管理应用程序。</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>Spring是一个完整的企业级框架，提供了大量的功能和灵活性，但需要较多的配置。而Spring Boot则是在Spring基础上构建的快速开发框架，通过约定优于配置和自动化配置，使得开发更加简单快速。一般情况下，如果你希望快速构建一个简单的应用程序，可以选择使用Spring Boot；而如果你需要更多的定制化和灵活性，可以选择使用Spring。</p>
<h2 id="Spring和Spring-MVC"><a href="#Spring和Spring-MVC" class="headerlink" title="Spring和Spring MVC"></a>Spring和Spring MVC</h2><p>Spring和Spring MVC是相关但不同的概念，下面将它们进行详细的解释：</p>
<h3 id="Spring-1"><a href="#Spring-1" class="headerlink" title="Spring:"></a>Spring:</h3><p>Spring是一个综合性的Java企业级应用开发框架，提供了多个模块和功能，用于解决企业级应用程序的各种开发问题。它是一个轻量级、模块化的框架，以IoC（控制反转）和DI（依赖注入）为核心，通过将应用程序的各个组件解耦，提高了代码的可维护性和可测试性。</p>
<p>Spring提供了许多功能，包括：</p>
<ul>
<li>IoC容器：管理Java对象的生命周期，实现对象的创建、依赖注入和销毁等。</li>
<li>AOP（面向切面编程）：实现横切关注点的解耦，如事务管理、日志记录等。</li>
<li>JDBC和ORM（对象关系映射）：支持数据库访问，可以使用JDBC或整合第三方ORM框架如Hibernate。</li>
<li>事务管理：提供声明式的事务管理，简化了事务的编程工作。</li>
<li>集成测试支持：提供了对JUnit等测试框架的整合，使得测试变得更加方便。</li>
</ul>
<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC:"></a>Spring MVC:</h3><p>Spring MVC是Spring框架的一个模块，专注于构建基于MVC（Model-View-Controller）模式的Web应用程序。它在Spring框架的基础上提供了一个灵活且功能强大的MVC框架，用于处理Web请求和生成Web响应。</p>
<p>Spring MVC的特点和功能已在前面的回答中详细解释。简而言之，它主要用于处理Web层的逻辑，包括URL映射、请求处理、视图渲染等，帮助开发者更方便地构建Web应用程序。</p>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>Spring是一个全面的Java企业级开发框架，包含了许多模块和功能，可以用于构建各种类型的应用程序。而Spring MVC是Spring框架中的一个模块，专门用于构建Web应用程序，它提供了基于MVC模式的Web开发功能，帮助开发者更轻松地构建Web应用。</p>
<p>除了Spring核心框架和Spring MVC，Spring还包含许多其他模块，这些模块提供了广泛的功能，用于解决企业级应用开发中的不同问题。以下是一些常见的Spring框架其他模块：</p>
<ol>
<li><p>Spring Boot：<br>Spring Boot是Spring框架的一个子项目，旨在简化Spring应用程序的配置和部署。它通过自动配置和约定优于配置的原则，使得开发者可以更快速地启动和构建独立的、生产级别的Spring应用程序。Spring Boot内置了很多常用的功能和第三方库，使得开发过程更加简单。</p>
</li>
<li><p>Spring Data：<br>Spring Data是用于简化数据访问层的模块。它提供了统一的数据访问抽象层，支持多种数据存储技术，包括关系数据库、NoSQL数据库、Redis、Elasticsearch等。Spring Data可以减少数据访问代码的编写，提供了强大的查询功能和事务管理。</p>
</li>
<li><p>Spring Security：<br>Spring Security是用于身份认证和授权的模块。它提供了一套安全框架，用于保护应用程序的资源和控制用户的访问权限。Spring Security可以集成到Spring应用程序中，帮助开发者实现各种安全功能，如用户认证、访问控制、记住我、单点登录等。</p>
</li>
<li><p>Spring Batch：<br>Spring Batch是用于批处理处理的模块。它提供了处理大量数据的功能，支持复杂的批处理作业。Spring Batch可以用于数据清洗、数据转换、数据导入导出等数据处理任务。</p>
</li>
<li><p>Spring Cloud：<br>Spring Cloud是用于构建分布式系统的模块。它提供了一系列功能，用于解决微服务架构中的问题，如服务注册与发现、负载均衡、断路器、配置中心等。Spring Cloud可以与其他云计算和微服务技术（如Netflix的Eureka、Ribbon、Hystrix等）集成，帮助构建可伸缩、高可用的分布式应用。</p>
</li>
<li><p>Spring Integration：<br>Spring Integration是用于构建企业集成应用程序的模块。它提供了一组组件，用于实现不同系统之间的消息传递、事件驱动等集成方式。</p>
</li>
<li><p>Spring WebFlux：<br>Spring WebFlux是用于构建响应式Web应用程序的模块。它基于Reactor框架，提供了对响应式编程的支持，使得应用程序可以处理大量并发请求，以及异步非阻塞的方式进行处理。</p>
</li>
</ol>
<p>除了上述模块，Spring框架还包含其他一些模块，用于提供更多的功能和扩展，以满足不同应用场景的需求。Spring框架的模块化设计允许开发者根据需要选择和整合所需的功能，使得开发更加灵活和高效。</p>
<h5 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h5><p>单点登录（Single Sign-On，简称SSO）是一种身份认证和访问控制的技术，旨在让用户在一次登录后，可以访问多个相互信任的应用系统，而无需为每个应用系统单独进行登录认证。在SSO中，用户只需登录一次，然后就可以自由地访问所有受信任的应用系统，而无需再次输入用户名和密码。</p>
<p>传统的Web应用程序在不同的应用系统之间是独立的，用户需要为每个应用系统单独进行登录认证。这样会导致用户频繁地输入用户名和密码，增加了用户的负担，并且对于系统管理员来说，也增加了管理的复杂性。SSO技术通过引入一个单独的身份认证中心（也称为认证服务器），解决了这个问题。</p>
<p>SSO的基本工作流程如下：</p>
<ol>
<li>用户访问一个需要认证的应用系统。</li>
<li>应用系统发现用户未登录或登录已过期，将用户重定向到身份认证中心。</li>
<li>用户在身份认证中心输入用户名和密码进行登录。</li>
<li>身份认证中心验证用户的身份，如果验证通过，会颁发一个认证凭证（例如令牌或票据）。</li>
<li>应用系统将认证凭证返回给用户的浏览器。</li>
<li>用户的浏览器将认证凭证带回给应用系统。</li>
<li>应用系统验证认证凭证的有效性，如果有效，则将用户登录到应用系统。</li>
</ol>
<p>SSO的优点包括：</p>
<ol>
<li>用户友好：用户只需一次登录，即可访问所有受信任的应用系统，提高了用户体验。</li>
<li>安全性：通过专门的身份认证中心进行身份验证，可以提高认证的安全性，并减少密码泄露的风险。</li>
<li>简化管理：减少了系统管理员的管理工作，因为用户的身份认证集中管理在认证中心中。</li>
<li>集成性：允许不同平台和技术的应用系统进行集成，实现统一的登录认证。</li>
</ol>
<p>一些常见的SSO技术包括OAuth、OpenID Connect、SAML（Security Assertion Markup Language）等。这些技术可以根据具体需求和场景来选择使用。</p>
<p>OAuth、OpenID Connect和SAML都是身份认证和授权相关的协议或标准，用于实现单点登录（SSO）和安全访问控制。它们在不同的场景下有不同的应用，下面对它们进行简要的介绍：</p>
<ol>
<li>OAuth：<br>OAuth是一个开放标准的授权协议，旨在允许用户授权第三方应用访问受保护资源，而无需将用户的用户名和密码透露给第三方应用。OAuth通常用于授权访问用户在一个服务提供者（例如，Facebook、Google）上的资源，以便其他应用可以通过授权令牌（Access Token）访问这些资源。</li>
</ol>
<p>OAuth的主要角色包括：</p>
<ul>
<li>资源拥有者（Resource Owner）：即用户，拥有受保护资源。</li>
<li>客户端（Client）：即第三方应用，希望访问用户的资源。</li>
<li>授权服务器（Authorization Server）：负责颁发访问令牌给客户端。</li>
<li>资源服务器（Resource Server）：存储受保护的资源，验证令牌并提供资源给客户端。</li>
</ul>
<ol start="2">
<li>OpenID Connect：<br>OpenID Connect是建立在OAuth 2.0之上的一个身份认证协议。它扩展了OAuth 2.0，添加了身份认证的功能，使得OAuth 2.0可以用于用户身份认证和单点登录。OpenID Connect允许客户端在用户的授权下获取用户的身份信息，同时也可以使用OAuth 2.0的访问令牌来访问受保护的资源。</li>
</ol>
<p>OpenID Connect的主要角色和OAuth类似，但增加了一个身份提供者（Identity Provider）的角色，负责验证用户的身份和提供用户信息。</p>
<ol start="3">
<li>SAML（Security Assertion Markup Language）：<br>SAML是一种基于XML的开放标准，用于进行跨域身份认证和授权。它允许身份提供者（IdP）和服务提供者（SP）之间交换认证和授权信息，实现单点登录和单点登出。</li>
</ol>
<p>SAML的主要角色包括：</p>
<ul>
<li>身份提供者（Identity Provider，IdP）：负责验证用户的身份，并向服务提供者提供认证和授权信息。</li>
<li>服务提供者（Service Provider，SP）：提供受保护的资源，接受来自身份提供者的认证和授权信息。</li>
</ul>
<p>SAML通常用于企业环境中，例如企业内部的不同应用系统之间实现单点登录，或者企业与合作伙伴之间实现跨组织的身份认证和授权。</p>
<p>总结：<br>OAuth、OpenID Connect和SAML都是用于身份认证和授权的协议或标准，它们在不同的场景下有不同的应用。OAuth主要用于授权访问资源，OpenID Connect扩展了OAuth，用于用户身份认证和单点登录，而SAML则用于跨域身份认证和授权。开发者在选择使用时，需要根据具体的需求和场景来进行合适的选择。</p>
<h2 id="Spring-Tool-Suite"><a href="#Spring-Tool-Suite" class="headerlink" title="Spring Tool Suite"></a>Spring Tool Suite</h2><p>在 Eclipse 上下文中，”STS” 通常指的是 “Spring Tool Suite”。</p>
<p>Spring Tool Suite (STS) 是一个基于 Eclipse IDE 的开发环境，专门为 Spring Framework 和相关项目提供支持。它由 Pivotal（现为 VMware 的一部分）开发和维护。STS 为 Spring 开发人员提供了一套强大的工具，使他们能够更轻松地开发、调试和部署 Spring 应用程序。</p>
<p>STS 提供了许多功能，包括：</p>
<ol>
<li><p>Spring 项目模板：可快速创建基于 Spring 的应用程序骨架，包括 Spring Boot 项目、Spring MVC 项目等。</p>
</li>
<li><p>代码自动完成：能够识别 Spring 相关的代码，并提供智能代码补全和代码导航。</p>
</li>
<li><p>Spring Bean 图形化编辑器：可以可视化显示 Spring 应用程序的组件和依赖关系。</p>
</li>
<li><p>调试和测试：集成了 Spring 应用程序的调试和单元测试功能。</p>
</li>
<li><p>内置 Maven 和 Gradle 支持：允许您使用这些构建工具来管理项目。</p>
</li>
<li><p>Spring Boot Dashboard：可轻松运行和监视 Spring Boot 应用程序。</p>
</li>
</ol>
<p>请注意，STS 的功能和特性可能会随着版本的更新而改变，因此具体的功能可能会有所不同。如果您是 Spring 开发人员，STS 是一个非常有用的开发工具，可以提高您的开发效率和舒适度。</p>
<h2 id="https-mvnrepository-com-repos-central-和-https-search-maven-org"><a href="#https-mvnrepository-com-repos-central-和-https-search-maven-org" class="headerlink" title="https://mvnrepository.com/repos/central 和 https://search.maven.org/"></a><a target="_blank" rel="noopener" href="https://mvnrepository.com/repos/central">https://mvnrepository.com/repos/central</a> 和 <a target="_blank" rel="noopener" href="https://search.maven.org/">https://search.maven.org/</a></h2><p>这两个网站都是与 Maven Central（Maven 中央仓库）相关的站点，但它们的功能和目的有一些区别：</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://mvnrepository.com/repos/central%EF%BC%9A">https://mvnrepository.com/repos/central：</a><br>这个网站是 Maven Repository 的一个子站点，专门用于展示 Maven Central（Maven 中央仓库）中的库和依赖项。它提供了一个更友好和易于搜索的界面，供开发者浏览和查找 Maven Central 中的库和依赖项。您可以在此站点上搜索和浏览 Maven Central 中的各种 Java 库、框架和工具，并查看它们的最新版本和相关信息。</p>
<p>主要特点：</p>
<ul>
<li>提供直观的搜索和浏览界面，方便查找和发现 Maven Central 中的库。</li>
<li>提供库的详细信息，包括最新版本、依赖关系、文档链接等。</li>
<li>提供 Maven 依赖坐标，以便将库添加到您的项目中。</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://search.maven.org/%EF%BC%9A">https://search.maven.org/：</a><br>这个网站是 Maven 官方提供的用于搜索 Maven Central（Maven 中央仓库）中的库和依赖项的站点。它是 Maven 的官方搜索引擎，提供更高级的搜索功能和与 Maven Central 数据库同步的实时结果。</p>
<p>主要特点：</p>
<ul>
<li>官方的 Maven 搜索引擎，提供实时的 Maven Central 数据。</li>
<li>支持高级搜索选项，可以按关键字、坐标、版本等多个条件进行精确搜索。</li>
<li>提供直接的 Maven 依赖代码片段，方便将库添加到您的项目中。</li>
</ul>
</li>
</ol>
<p>综上所述，这两个网站都是用于搜索和查找 Maven Central 中的库和依赖项的工具，但 <a target="_blank" rel="noopener" href="https://mvnrepository.com/repos/central">https://mvnrepository.com/repos/central</a> 更侧重于提供更简单和直观的界面，供开发者快速查找和浏览库，而 <a target="_blank" rel="noopener" href="https://search.maven.org/">https://search.maven.org/</a> 则更专注于提供官方的高级搜索功能，以满足更复杂的搜索需求。您可以根据个人喜好和需求选择使用其中之一。<br>简单复制坐标添加到pom.xml中，使用这两个链接中的哪个都无所谓。这是因为两个链接都提供了相同的信息：Maven构件的坐标。坐标是在Maven项目中标识依赖项的唯一方式，它由groupId、artifactId和version组成。</p>
<h3 id="“Maven-POM-File”和”Snippets”"><a href="#“Maven-POM-File”和”Snippets”" class="headerlink" title="“Maven POM File”和”Snippets”"></a>“Maven POM File”和”Snippets”</h3><p>在 <a target="_blank" rel="noopener" href="https://central.sonatype.com/artifact/org.mybatis/mybatis/3.5.13">https://central.sonatype.com/artifact/org.mybatis/mybatis/3.5.13</a> 页面中，”Maven POM File”和”Snippets”之间的区别如下：</p>
<ol>
<li><p>Maven POM File（Maven项目对象模型文件）：<br>这是一个完整的Maven项目对象模型文件，通常称为pom.xml。POM文件是用于构建和管理Maven项目的核心文件。它包含项目的元数据，如项目的坐标、依赖项、插件、构建配置等。在这个链接中，”Maven POM File”将会提供您在Maven项目中使用MyBatis 3.5.13时所需的完整pom.xml文件。您可以直接将该文件复制到您的项目中，然后进行适当的调整以满足您的项目需求。</p>
</li>
<li><p>Snippets（代码片段）：<br>这里的”Snippets”是指一些代码片段或示例代码，而不是完整的POM文件。这些代码片段通常是针对某个特定用例或配置的小段代码，您可以将它们复制到您的项目中，以实现特定的功能或配置。在这个链接中，”Snippets”可能会提供一些在Maven项目中集成MyBatis 3.5.13的代码示例，比如如何添加依赖项或配置MyBatis。</p>
</li>
</ol>
<p>总的来说，”Maven POM File”提供了一个完整的、可用于构建整个项目的pom.xml文件，而”Snippets”提供了一些用于特定用途的代码片段。如果您需要将MyBatis 3.5.13集成到一个新的Maven项目中，您可以使用”Maven POM File”，如果您只需要一些特定的配置或示例代码，您可以查看”Snippets”部分。</p>
<h2 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h2><p>Thymeleaf是一种Java服务器端模板引擎，用于构建Web应用程序。它允许开发人员在服务器端生成HTML页面，并在渲染时将动态数据注入到HTML中。Thymeleaf的设计目标是将模板的可读性和有效性与自然的HTML模板语法结合在一起。</p>
<p>使用Thymeleaf，您可以在HTML模板中使用类似于普通HTML的标记，同时也可以插入表达式来动态地渲染内容。它与Spring Framework等Java Web开发框架密切结合，特别是与Spring Boot一起使用，这使得开发Web应用程序更加方便。</p>
<p>Thymeleaf的主要特点包括：</p>
<ol>
<li><p>自然的HTML模板语法：模板与普通HTML文件的区别非常小，这使得模板很容易编写和维护。</p>
</li>
<li><p>表达式语言：使用Thymeleaf的表达式语言，您可以在模板中插入动态内容，访问后端数据，并执行条件判断和迭代等操作。</p>
</li>
<li><p>可以在浏览器端进行渲染：与某些服务器端模板引擎不同，Thymeleaf支持在服务器端和客户端两个阶段进行渲染。这使得在浏览器端执行JavaScript时，页面已经包含了动态数据，从而提高了用户体验。</p>
</li>
<li><p>支持国际化：Thymeleaf具有内置的国际化支持，使得多语言应用程序的开发和管理更加便捷。</p>
</li>
</ol>
<p>总的来说，Thymeleaf是一个强大且易于使用的服务器端模板引擎，它在Java Web应用程序的开发中发挥着重要的作用。</p>
<h3 id="Thymeleaf和JSP"><a href="#Thymeleaf和JSP" class="headerlink" title="Thymeleaf和JSP"></a>Thymeleaf和JSP</h3><p>您的感觉是正确的，Thymeleaf和JSP（JavaServer Pages）在某些方面确实有一些相似之处。它们都是用于在服务器端生成动态HTML页面的技术，但也有一些重要的区别。</p>
<p>相似之处：</p>
<ol>
<li><p>动态HTML生成：Thymeleaf和JSP都允许在服务器端生成动态HTML页面。您可以在模板或JSP文件中嵌入Java代码和表达式，将动态数据注入到页面中。</p>
</li>
<li><p>集成Spring框架：Thymeleaf和JSP都可以与Spring Framework（尤其是Spring Boot）集成，使得在开发Java Web应用程序时更加方便。</p>
</li>
</ol>
<p>不同之处：</p>
<ol>
<li><p>语法：Thymeleaf和JSP有不同的语法。JSP使用特殊的标签（例如&lt;% %&gt;）来嵌入Java代码，而Thymeleaf使用自然的HTML标签和表达式，使得模板的可读性更好。</p>
</li>
<li><p>跨平台支持：JSP通常与Java Servlet容器一起使用，例如Tomcat。而Thymeleaf是一个独立的模板引擎，不仅可以与Java Servlet容器一起使用，还可以在其他环境中（例如Spring WebFlux）使用。</p>
</li>
<li><p>时机：JSP是在运行时动态地生成HTML，它使用Java编程语言处理数据并生成内容。Thymeleaf可以在运行时和服务器端预渲染之前进行处理，也可以在浏览器端通过JavaScript执行，根据具体的应用场景进行选择。</p>
</li>
<li><p>可读性：由于Thymeleaf使用自然的HTML标签，它的模板通常更易于阅读和理解，特别是对于前端开发人员来说，因为他们可以更容易地识别和理解HTML结构。</p>
</li>
</ol>
<p>总体而言，Thymeleaf提供了一种更加现代化和易于使用的模板引擎，尤其适合与Spring框架集成。而JSP在一些项目中可能仍然是一种常用的选择，特别是在传统的Java Web开发中。</p>
<h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>Java中的ORM代表对象关系映射(Object-Relational Mapping)，它是一种技术，用于在关系型数据库和面向对象编程语言（如Java）之间建立映射，使得数据库中的表与Java中的类、对象之间可以进行相互转换。这使得开发人员可以使用面向对象的方式来操作数据库，而不需要直接编写SQL查询语句。</p>
<p>以下是一些Java中常见的ORM框架：</p>
<ol>
<li><p>Hibernate：Hibernate是最为知名和广泛使用的Java ORM框架之一。它提供了强大的对象-数据库映射功能，允许开发人员通过配置文件或注解将Java类映射到数据库表，同时提供了查询语言（HQL）来执行数据库操作。</p>
</li>
<li><p>JPA（Java Persistence API）：JPA是一种Java的ORM标准规范，定义了一组API，使得开发人员可以通过注解或XML配置来实现对象-数据库映射。JPA本身只是规范，不是一个具体的实现，但许多ORM框架（如Hibernate、EclipseLink）都实现了JPA规范。</p>
</li>
<li><p>MyBatis：MyBatis是另一种流行的Java ORM框架，它采用XML配置文件来定义SQL映射，可以更精细地控制SQL语句的编写和执行。与Hibernate和JPA不同，MyBatis更加接近SQL，适用于需要更多控制的情况。</p>
</li>
<li><p>EclipseLink：EclipseLink也是一个实现了JPA规范的ORM框架，它提供了高性能和丰富的特性，适用于复杂的应用场景。</p>
</li>
</ol>
<p>ORM框架的使用可以大大简化数据库操作，提高开发效率，但在选择框架时需要考虑项目需求、性能要求和开发团队的熟悉程度。每个框架都有其特定的优点和适用范围，您可以根据具体情况选择最适合您项目的框架。</p>
<h2 id="DAO-和-Entity"><a href="#DAO-和-Entity" class="headerlink" title="DAO 和 Entity"></a>DAO 和 Entity</h2><p>“dao” 是指数据访问对象（Data Access Object），而 “entity” 是指实体对象，通常用于映射数据库表中的数据。</p>
<p>在 Spring 中，”DAO” 通常是一个用于执行数据库操作的接口或类，而 “Entity” 是一个用于映射数据库表结构的 Java 类。下面我会分别介绍它们的作用和一般的实现方式：</p>
<ol>
<li><p><strong>DAO（数据访问对象）</strong>：</p>
<ul>
<li>DAO 是用于访问数据库并执行 CRUD（创建、读取、更新、删除）操作的对象。</li>
<li>它将业务逻辑与底层数据库操作解耦，使得应用程序能够更容易维护和测试。</li>
<li>通常，DAO 包含了针对实体对象的持久化方法，如保存、更新、查询等。</li>
</ul>
<p>示例代码（基于 Spring Data JPA）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    User <span class="title function_">findByUsername</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>UserDao</code> 是一个 DAO 接口，继承了 Spring Data JPA 提供的 <code>JpaRepository</code> 接口，它会自动为 <code>User</code> 实体生成一些常用的数据库操作方法。</p>
</li>
<li><p><strong>Entity（实体）</strong>：</p>
<ul>
<li>Entity 是一个普通的 Java 类，通常用于映射数据库表的结构。每个 Entity 类对应数据库中的一个表。</li>
<li>Entity 类中的属性与表中的列相对应，使用注解进行映射。</li>
<li>通过实体类，可以进行数据库记录的创建、查询、更新和删除等操作。</li>
</ul>
<p>示例代码（基于 JPA 注解）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getters, setters, constructors...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>上述示例中的 <code>UserDao</code> 接口和 <code>User</code> 实体类演示了 Spring 中使用 DAO 和 Entity 的典型方式，特别是在使用 Spring Data JPA 进行数据库访问的情况下。不同的持久化技术可能会有不同的实现方式，但核心概念通常是相似的。根据您的具体需求和技术栈，可能会有一些细微的差异。</p>
<h2 id="Jakarta"><a href="#Jakarta" class="headerlink" title="Jakarta"></a>Jakarta</h2><p>import jakarta.persistence.Entity;<br>Jakarta 是一个用于构建企业级 Java 应用程序的开源软件平台和技术生态系统。它起源于 Java 企业版（Java EE）平台，但后来发展成为一个由 Eclipse 基金会主导的项目。Jakarta 项目的目标是在开放和协作的社区中继续发展和推进 Java 企业级技术。</p>
<p>在过去，Java EE 是一套用于开发企业级应用程序的标准，提供了许多特性，如 Servlet、JSP、EJB 等。然而，由于发展进程相对缓慢和对开源社区的限制，Java EE 的发展逐渐受到了批评。于是，Java EE 社区的一些成员选择创建 Jakarta 项目，以在更开放和快速的环境中推动企业级 Java 技术。</p>
<p>Jakarta 项目包括许多子项目，这些子项目涵盖了多个领域，如 Web 应用开发、持久性、消息传递、安全性等。其中一些子项目是：</p>
<ul>
<li>Jakarta Servlet：用于开发基于 Java 的 Web 应用程序的 API。</li>
<li>Jakarta Persistence：提供 Java 对象和数据库之间的持久化机制，类似于 JPA（Java Persistence API）。</li>
<li>Jakarta Messaging：用于消息传递和异步通信的 API。</li>
<li>Jakarta Security：处理应用程序的安全性和身份验证授权。</li>
<li>等等。</li>
</ul>
<p>总的来说，Jakarta 项目旨在推动 Java 在企业级应用开发中的创新，促进开源社区的参与和贡献，以满足不断变化的企业级应用需求。它是 Java 生态系统中一个重要的开源项目，为开发者提供了更多选择和灵活性。</p>
<h2 id="github的workflow和action"><a href="#github的workflow和action" class="headerlink" title="github的workflow和action"></a>github的workflow和action</h2><p>GitHub Actions 是 GitHub 提供的一项功能，用于自动化软件开发工作流程。Workflow 是一组定义在存储库中的自动化任务，这些任务可以在特定事件触发时自动执行。每个 Workflow 由一个或多个 Action 组成，这些 Action 是可重复使用的任务单元，用于执行各种操作，如构建、测试、部署等。</p>
<p>下面是有关 GitHub Workflow 和 Actions 的一些关键概念：</p>
<ol>
<li><p><strong>Workflow</strong>：</p>
<ul>
<li>Workflow 是一组指令，定义了在特定事件触发时自动执行的操作。</li>
<li>每个 Workflow 通常由一个或多个步骤（Steps）组成。</li>
<li>Workflow 文件以 <code>.yml</code> 格式定义，存储在存储库的 <code>.github/workflows</code> 目录下。</li>
</ul>
</li>
<li><p><strong>Action</strong>：</p>
<ul>
<li>Action 是一个独立的任务单元，用于执行特定操作，如构建、测试、发布等。</li>
<li>您可以自定义 Action，也可以使用其他用户或组织创建的公共 Action。</li>
<li>Actions 可以在 Workflow 中按顺序组成步骤，以创建复杂的自动化流程。</li>
</ul>
</li>
<li><p><strong>事件</strong>：</p>
<ul>
<li>事件是触发 Workflow 执行的原因，如推送代码、发起 Pull 请求、发布新版本等。</li>
<li>每个事件类型都可以触发不同的 Workflow，以便在特定事件发生时自动执行相应的操作。</li>
</ul>
</li>
<li><p><strong>工作流程示例</strong>：</p>
<ul>
<li>一个简单的工作流程可以包含一系列步骤，如构建代码、运行测试、部署到服务器等。</li>
<li>您可以通过在 <code>.github/workflows</code> 目录中创建一个 Workflow 文件来定义这些步骤。</li>
<li>Workflow 文件会包含事件、触发条件和具体的步骤配置。</li>
</ul>
</li>
</ol>
<p>下面是一个简单的 Workflow 示例，用于在代码推送时自动构建和测试项目：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">code</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">JDK</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-java@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">java-version:</span> <span class="string">&#x27;11&#x27;</span></span><br><span class="line">        </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">with</span> <span class="string">Maven</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">mvn</span> <span class="string">clean</span> <span class="string">install</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">Tests</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">mvn</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>

<p>上述示例中，Workflow 名称为 “Build and Test”，当在 <code>main</code> 分支上推送代码时会触发。工作流程包含一个 <code>build</code> 作业，其中定义了一系列步骤，包括检出代码、设置 Java 环境、构建代码和运行测试。</p>
<p>这只是 GitHub Workflow 和 Actions 的一个简单介绍。实际上，您可以创建更复杂和定制化的工作流程，根据您的项目需求自动化各种任务，从代码构建到部署等。GitHub Actions 可以大大简化开发和 CI&#x2F;CD 过程，并为团队提供高效的自动化工具。</p>
<h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p>前端中的 Canvas 是 HTML5 提供的一个元素，它可以用于在网页上绘制图形、图像和动画。Canvas 元素允许你使用 JavaScript 通过绘制 API 在一个矩形区域内绘制各种图形，从而创建交互性和动态性更强的网页内容。</p>
<p>Canvas 本质上是一个类似画布的区域，你可以在上面绘制各种元素，比如线条、形状、文本、图像等。它的工作方式是通过 JavaScript 脚本操作绘制 API 来绘制内容。你可以控制图形的属性，如颜色、线型、填充等，也可以实现动画、交互和视觉效果。</p>
<p>使用 Canvas 可以创建各种类型的应用，包括游戏、图表、图像编辑器、动画等。它的灵活性和强大性使得开发者可以实现许多复杂的前端交互和视觉效果。</p>
<p>以下是一个简单的示例，展示了如何在 Canvas 上绘制一个红色的矩形：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Canvas 示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取 Canvas 元素的引用</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myCanvas&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取绘制上下文</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> context = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 绘制一个红色的矩形</span></span></span><br><span class="line"><span class="language-javascript">        context.<span class="property">fillStyle</span> = <span class="string">&quot;red&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">150</span>, <span class="number">80</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>getContext(&quot;2d&quot;)</code> 方法获取了一个 2D 绘制上下文，通过设置 <code>fillStyle</code> 属性为 “red” 并使用 <code>fillRect()</code> 方法绘制了一个红色的矩形。</p>
<p>总之，Canvas 是前端开发中用于绘制图形和实现交互性的强大工具，通过 JavaScript 控制绘制 API，可以创建各种视觉效果和动态内容。</p>

                    
          </div>
          <footer>
            
                        
                          
  
  <div class="tags">
    <a href="/tags/Note/">Note</a>
  </div>

                            
                              <div class="clearfix"></div>
          </footer>
        </div>
</article>


<!-- 是否开启评论？ -->
</div>
      </div>
      <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="as_sitesearch" value="jutta.top">
  </form>
</div>


  
<div class="widget tag">
  <h3 class="title">Categories</h3>
  <ul class="entry">
  
    <li><a href="/categories/Front-End/">Front-End</a><small>1</small></li>
  
    <li><a href="/categories/%E4%BA%91%E6%9C%8D%E5%8A%A1/">云服务</a><small>7</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/AWS/">AWS</a><small>7</small></li>
  
    <li><a href="/tags/Hexo/">Hexo</a><small>1</small></li>
  
    <li><a href="/tags/Note/">Note</a><small>4</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">Tag Cloud</h3>
  <div class="entry">
    <a href="/tags/AWS/" style="font-size: 20px;">AWS</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Note/" style="font-size: 15px;">Note</a>
  </div>
</div>

</aside>
      <div class="clearfix"></div>
    </div>
    <!-- 这里是改动过的 -->
    <div id="footer" class="inner">
      <p>IP: <span id="ipAddress"></span></p>
      <p>Language: <span id="browserLanguage"></span></p>
    </div>
    <footer id="footer" class="inner"><div class="alignleft">
  
    &copy; 2023
      Jutta
        
</div>
<div class="clearfix"></div></footer>

    
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

  </body>

</html>