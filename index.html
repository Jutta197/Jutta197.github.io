<!DOCTYPE HTML>
<html lang="en">
<head>

  <meta charset="utf-8">
  
    <title>
      Jutta&#39;s Blog</title>
  <meta name="author" content="Jutta">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Jutta&#39;s Blog"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/%20favicon.png">
        
                  
<link rel="stylesheet" href="/css/style.css">

                    <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
                    

<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <!-- 这里是改动过的 -->
    <!-- 插入获取IP地址和浏览器语言的JavaScript代码 -->
    <script>
      fetch('https://api.ipify.org?format=json')
        .then(response => response.json())
        .then(data => {
          const ipAddress = data.ip;
          document.getElementById('ipAddress').textContent = ipAddress;
        })
        .catch(error => console.error(error));

      const browserLanguage = navigator.language;
      document.getElementById('browserLanguage').textContent = browserLanguage;
    </script>


    <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">
      Jutta&#39;s Blog
    </a></h1>
  <h2><a href="/">
      
        勿以浮沙築高台
          
    </a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/null">
          Home
        </a></li>
      
      <li><a href="/archives">
          Archives
        </a></li>
      
      <li><a href="/jutta">
          About me
        </a></li>
      
        <!-- <li><a href="https://github.com/test" target="_blank" rel="noopener noreferrer">GitHub</a></li> -->
        <!-- <li><a href="https://test.medium.com" target="_blank" rel="noopener noreferrer">Medium</a></li> -->
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
    <div id="content" class="inner">

      <div id="main-col" class="alignleft">
        <div id="wrapper">
  <article id="post-ip-and-lang-test" class="h-entry post" itemprop="blogPost" itemscope
  itemtype="https://schema.org/BlogPosting">
  
        <div class="post-content">
          <header>
            
              <div class="icon"></div>
              <time class="dt-published" datetime="2023-08-25T14:54:12.000Z"><a
                  href="/2023/08/25/ip-and-lang-test/">
                  2023-08-25
                </a></time>
              
                
  
    <h1 class="title"><a href="/2023/08/25/ip-and-lang-test/">ip and lang test</a></h1>
  

          </header>
          <div class="e-content entry" itemprop="articleBody">
            
                  <!-- 在这里插入获取IP地址的JavaScript代码 -->
<script>
fetch('https://ipinfo.io')
  .then(response => response.json())
  .then(data => {
    const ipAddress = data.ip;
    console.log(ipAddress);
  })
  .catch(error => console.error(error));
</script>

<!-- 在这里插入获取浏览器语言的JavaScript代码 -->
<script>
const browserLanguage = navigator.language;
console.log(browserLanguage);
</script>

<p>这是正文的Markdown内容。</p>

                    
          </div>
          <footer>
            
              
                  
                      
                              <div class="clearfix"></div>
          </footer>
        </div>
</article>


<!-- 是否开启评论？ -->


  <article id="post-note-230824" class="h-entry post" itemprop="blogPost" itemscope
  itemtype="https://schema.org/BlogPosting">
  
        <div class="post-content">
          <header>
            
              <div class="icon"></div>
              <time class="dt-published" datetime="2023-08-24T15:59:21.000Z"><a
                  href="/2023/08/24/note-230824/">
                  2023-08-24
                </a></time>
              
                
  
    <h1 class="title"><a href="/2023/08/24/note-230824/">note_230824</a></h1>
  

          </header>
          <div class="e-content entry" itemprop="articleBody">
            
                  <span id="more"></span>
<p>在大多数现代框架和应用程序设计中，我们通常会听到“models”和“entities”这样的术语。它们与POJO有关，但又有所不同，取决于上下文和框架。</p>
<ol>
<li><p><strong>Models</strong>: 在MVC（模型-视图-控制器）设计模式中，“model”通常指代用于表示数据的对象。它不仅包括数据，还可能包括与数据相关的业务逻辑。</p>
</li>
<li><p><strong>Entities</strong>: 在许多ORM（对象关系映射）框架（如Hibernate、JPA、MyBatis等）中，“entity”是一个特殊的POJO，它代表了数据库中的一个表。Entities通常会有特定的注解或配置来描述如何将对象的字段映射到数据库表的列。例如，在JPA中，你会使用<code>@Entity</code>注解来标记一个Java类作为实体。</p>
</li>
</ol>
<p>可以说，一个entity是一个特殊的model，它直接与数据库中的数据表相对应。同时，entity也是一个特殊的POJO，因为它通常会包含一些特定的注解或元数据，以描述如何与数据库进行交互。</p>
<p>简单例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>  <span class="comment">// JPA注解，标识这是一个entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;person_table&quot;)</span>  <span class="comment">// 指定对应的数据库表名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span>  <span class="comment">// 标识这是一个主键</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>  <span class="comment">// 主键的生成策略</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;person_name&quot;)</span>  <span class="comment">// 指定对应的数据库列名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他字段、getter、setter和方法 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Person</code>类是一个entity，它代表了名为<code>person_table</code>的数据库表。尽管它有一些特定的注解，但在Java代码的层面上，它仍然是一个POJO。</p>
<p>总之，entity通常是models的一部分，但并非所有models都是entities。而所有的entities基本上都是POJO，但它们包含了额外的元数据来描述如何与数据库进行交互。</p>
<p>在Java的持久化框架JPA（Java Persistence API）中，当你创建一个实体类（entity）来映射数据库表时，经常需要为该实体的某个字段（通常是主键字段）定义一个生成策略，以决定该字段的值如何生成。</p>
<p><code>@GeneratedValue</code> 注解用于指定这种生成策略。它通常与 <code>@Id</code> 注解一起使用，后者标识实体的主键字段。</p>
<p><code>strategy</code> 属性是 <code>@GeneratedValue</code> 的核心属性，它定义了主键的生成策略。以下是常见的几种策略：</p>
<ol>
<li><p><strong>GenerationType.IDENTITY</strong>:</p>
<ul>
<li>这种策略意味着主键的值由数据库自动生成，通常通过自增字段完成。当插入一个新记录时，数据库会自动为这个自增字段生成一个新值。</li>
<li>这种策略特别适合那些支持自增主键的数据库，如MySQL的<code>AUTO_INCREMENT</code>、PostgreSQL的<code>SERIAL</code>等。</li>
</ul>
</li>
<li><p><strong>GenerationType.SEQUENCE</strong>:</p>
<ul>
<li>使用数据库的序列来生成主键值。</li>
<li>这需要数据库支持序列（例如Oracle、PostgreSQL等）。</li>
<li>这种策略还可以通过 <code>@SequenceGenerator</code> 注解来定制，例如指定序列名称、初始值、增量等。</li>
</ul>
</li>
<li><p><strong>GenerationType.TABLE</strong>:</p>
<ul>
<li>这种策略使用一个特定的数据库表来模拟序列，并从该表中获取主键值。</li>
<li>这是一种可移植的策略，可用于不支持序列的数据库。</li>
</ul>
</li>
<li><p><strong>GenerationType.AUTO</strong>:</p>
<ul>
<li>默认策略。JPA实现会根据数据库的特性选择最合适的策略（可能是<code>IDENTITY</code>、<code>SEQUENCE</code>或<code>TABLE</code>）。</li>
<li>这可以确保代码的可移植性，但有时可能不如明确指定策略那么高效。</li>
</ul>
</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他字段和方法 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>id</code> 字段是 <code>Person</code> 实体的主键，其值由数据库自动生成，使用数据库的自增机制。当你向数据库中插入一个新的 <code>Person</code> 时，不需要手动为 <code>id</code> 字段赋值，数据库会自动为它生成一个唯一的值。</p>
<p>POJO 是 “Plain Old Java Object” 的缩写，直译为“普通的旧Java对象”。但实际上，这个术语的意思是一个普通的Java对象，不受任何特定Java框架或环境的限制。POJO的概念由Martin Fowler, Rebecca Parsons, Josh MacKenzie于2000年提出，目的是强调业务逻辑应该在一个不依赖特定编程模型的简单对象中进行编写。</p>
<p>特点：</p>
<ol>
<li><strong>没有约束</strong>：它不必继承或实现某些特定的接口或类。</li>
<li><strong>不包含业务逻辑</strong>：它通常只包含属性（fields）、它们的getter和setter方法，以及其他标准Java对象方法（如 <code>toString()</code>, <code>equals()</code>, <code>hashCode()</code> 等）。</li>
<li><strong>不依赖特定的框架</strong>：它不应该包含任何与特定框架或方法关联的注解或配置。</li>
</ol>
<p>例子：</p>
<p>以下是一个简单的POJO，表示一个人：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认的无参构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter 和 Setter 方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他标准方法，例如 toString()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person[name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此对象只是一个简单的Java对象，没有继承任何特定的基类，也没有实现任何特定的接口。它也没有任何特定的注解或其他与框架相关的元数据。</p>
<p>POJO的概念对于Java开发很重要，因为它鼓励开发者创建松耦合、可重用和可维护的代码。</p>
<p>在Spring Boot应用中，<code>server.servlet.context-path</code> 是一个属性，用于设置应用的上下文路径。换句话说，它定义了应用的基础URI路径。</p>
<p>如果你设置了这个属性，例如 <code>server.servlet.context-path=/boot</code>，那么所有的应用映射都会基于这个路径。这意味着你必须在请求的URI前加上<code>/boot</code>来访问你的应用。</p>
<p>举例：</p>
<ol>
<li>假设你有一个如下的控制器映射：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果你<strong>没有</strong>设置 <code>server.servlet.context-path</code>，你可以通过以下URL访问该方法：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/hello</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>但是，如果你设置了 <code>server.servlet.context-path=/boot</code>，那么你应该使用以下URL来访问上述方法：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/boot/hello</span><br></pre></td></tr></table></figure>

<p>这个属性在以下情况下特别有用：</p>
<ul>
<li>当你想把多个Spring Boot应用部署在同一个服务器上时，可以为每个应用设置一个唯一的上下文路径。</li>
<li>当你的应用需要与其他系统或应用共享同一主机名和端口，但需要有其独特的基础路径时。</li>
<li>当你需要将你的Spring Boot应用与其他非Spring Boot应用混合部署在同一服务器上时。</li>
</ul>
<p>在Spring (和特别是Spring Boot) 中，<code>@RequestMapping</code> 和 <code>@GetMapping</code> 都是用来处理HTTP请求的注解。但它们之间存在一些差异：</p>
<ol>
<li><p><strong>定义和用途</strong>:</p>
<ul>
<li><code>@RequestMapping</code>: 是一个通用的注解，用于定义一个请求映射。你可以使用它来处理任何类型的HTTP请求（如GET, POST, PUT, DELETE等）。</li>
<li><code>@GetMapping</code>: 是一个组合注解，其实是 <code>@RequestMapping</code> 的一个缩写版本，专门用来处理HTTP GET请求。</li>
</ul>
</li>
<li><p><strong>属性</strong>:</p>
<ul>
<li><code>@RequestMapping</code>:<ul>
<li><code>value</code> 或 <code>path</code>: 请求的URL。</li>
<li><code>method</code>: HTTP请求方法（例如 <code>RequestMethod.GET</code> 或 <code>RequestMethod.POST</code>）。</li>
<li>还有其他属性，例如 <code>headers</code>, <code>params</code>, <code>consumes</code>, 和 <code>produces</code>。</li>
</ul>
</li>
<li><code>@GetMapping</code>: 主要属性是<code>value</code> 或 <code>path</code>，但它是固定处理GET请求的。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<p>使用<code>@RequestMapping</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>@GetMapping</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>简洁性</strong>:</p>
<ul>
<li>使用 <code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code> 和 <code>@PatchMapping</code> 可以使你的代码更简洁、更具可读性，因为你不再需要指定 <code>method</code> 属性。</li>
</ul>
</li>
<li><p><strong>版本</strong>:</p>
<ul>
<li><code>@RequestMapping</code> 在早期的Spring版本中就存在。</li>
<li><code>@GetMapping</code> 及其兄弟注解 (<code>@PostMapping</code>, <code>@PutMapping</code> 等) 在Spring 4.3中被引入，因此，如果你在使用较老的Spring版本，可能不会有这些组合注解。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>: 选择哪个注解取决于你的具体需求和所使用的Spring版本。对于Spring 4.3及更高版本，为了简洁和明确性，许多开发人员更喜欢使用<code>@GetMapping</code>和其兄弟注解。但<code>@RequestMapping</code>更通用，适用于所有情况。</p>
<p>Spring Boot推崇的是一个约定优于配置的理念，所以它对于项目的结构有一个默认的推荐，但不是强制的。当使用Spring Boot和MVC设计模式时，你通常会看到以下的文件夹结构：</p>
<ol>
<li><p><strong>src&#x2F;main&#x2F;java</strong>: 该文件夹包含所有的Java源代码。</p>
<ul>
<li><strong>com.example.projectname.controller</strong>: 这里存放所有的控制器类。这些类通常负责处理HTTP请求，并返回相应的视图或数据。</li>
<li><strong>com.example.projectname.model</strong>: 这里存放模型类。模型可以代表应用的业务逻辑，也可以是与数据库表对应的实体。</li>
<li><strong>com.example.projectname.repository</strong> (或 <strong>dao</strong>): 这里存放数据访问对象或仓库接口。在Spring Data JPA中，这通常是一些接口，用于与数据库交互。</li>
<li><strong>com.example.projectname.service</strong>: 这里存放服务类。服务类通常封装了业务逻辑，并被控制器调用。</li>
<li><strong>com.example.projectname.config</strong>: 用于存放配置类，如安全配置、数据库配置等。</li>
<li><strong>com.example.projectname.dto</strong>: （如果需要的话）这里存放数据传输对象（DTO）。DTOs常用于从控制器向前端传递数据或从前端接收数据，特别是当实体类与API客户端需要的数据结构不完全匹配时。</li>
</ul>
</li>
<li><p><strong>src&#x2F;main&#x2F;resources</strong>:</p>
<ul>
<li><strong>static</strong>: 存放静态资源，如CSS、JavaScript、图片等。</li>
<li><strong>templates</strong>: 如果你使用的是模板引擎（如Thymeleaf、Freemarker等），则此处存放模板文件，它们将由控制器用于生成HTML视图。</li>
<li><strong>application.properties</strong> 或 <strong>application.yml</strong>: 主配置文件，用于配置Spring Boot应用。</li>
</ul>
</li>
<li><p><strong>src&#x2F;test&#x2F;java</strong>: 存放测试类，通常为上面提到的每个组件都提供相应的测试。</p>
</li>
</ol>
<p>这只是一个常见的Spring Boot项目结构，实际上，你可以根据项目的需求和团队的偏好进行调整。但遵循这样的结构可以确保你的项目组织得当，易于维护，且与其他Spring Boot项目保持一致性。</p>
<p>LoginController:<br>返回的模板名称不应包含文件扩展名：在 Spring Boot 中，当你使用 Thymeleaf (或其他模板引擎) 时，你应该只返回模板的名称，不包括 .html。Spring Boot 和 Thymeleaf 将会自动寻找这个名字的模板文件。</p>
<p>DAO，全称为Data Access Object（数据访问对象），是一个设计模式，用于从数据源（如数据库、XML文件、REST API等）中抽象和封装数据访问逻辑。其核心思想是将数据访问逻辑与业务逻辑分离，使得业务逻辑不直接依赖于数据源的具体实现，从而提高代码的模块性和可维护性。</p>
<p>以下是DAO的主要特点和功能：</p>
<ol>
<li><p><strong>抽象性</strong>：DAO模式提供了一种高度抽象的方式来访问数据。不同的数据存储机制（例如关系数据库、NoSQL数据库、文件系统等）可以有不同的DAO实现。</p>
</li>
<li><p><strong>隔离性</strong>：由于业务逻辑与数据访问逻辑分离，更改底层数据存储机制或数据库的实现细节不会影响到上层的业务逻辑。这样，如果你决定从一个数据库迁移到另一个数据库，只需更改DAO实现，而不是整个应用程序。</p>
</li>
<li><p><strong>统一的API</strong>：所有的DAO通常会提供一个统一的API（如增、删、查、改），使得应用程序能够以统一的方式处理数据。</p>
</li>
<li><p><strong>易于测试</strong>：因为DAO提供了数据访问的抽象，所以可以更容易地为它编写单元测试。你可以创建模拟的DAO实现来测试上层的业务逻辑，而无需连接真实的数据库。</p>
</li>
</ol>
<p>在Java和许多现代框架中（如Spring和Java EE&#x2F;Jakarta EE），DAO模式被广泛使用。以下是一个简单的Java + Spring的DAO示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonDAO</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addPerson</span><span class="params">(Person person)</span>;</span><br><span class="line">    Person <span class="title function_">getPersonById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    List&lt;Person&gt; <span class="title function_">getAllPersons</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deletePerson</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updatePerson</span><span class="params">(Person person)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonDAOImpl</span> <span class="keyword">implements</span> <span class="title class_">PersonDAO</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPerson</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        <span class="comment">// jdbcTemplate logic to add person</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">getPersonById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// jdbcTemplate logic to get person by id</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... other methods&#x27; implementations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>PersonDAO</code>接口定义了数据访问的方法，而<code>PersonDAOImpl</code>类提供了这些方法的实现，使用Spring的<code>JdbcTemplate</code>来与关系数据库进行交互。</p>
<p>当使用如Spring Data JPA这样的更高级框架时，DAO的实现甚至可能更加简洁，因为该框架提供了自动化的数据访问方法，无需手动编写SQL或其他数据访问代码。</p>
<p>JpaRepository:</p>
<p>AccountDao继承了JpaRepository，这意味着它自动继承了很多标准的CRUD（创建、读取、更新和删除）方法，例如save(), findOne(), findAll(), count(), delete()等。<br>通过继承JpaRepository&lt;AccountEntity, Long&gt;，你告诉Spring Data JPA这个DAO是用于AccountEntity这个实体，并且该实体的主键是Long类型。<br>使用Spring Data JPA的好处之一是，只要你按照其命名规范定义了方法名，它就会为你自动生成相关的查询，无需手动编写SQL或其他查询代码。</p>
<p>findByAccountName(String accountName):</p>
<p>此方法用于根据给定的账户名查询一个AccountEntity。<br>Spring Data JPA允许你通过方法名定义查询，findByAccountName会被自动解析为一个查询，其大致意思是“从AccountEntity找到一个实体，其中AccountName属性等于给定的值”</p>
<p>使用Spring Data JPA来定义DAO是非常简便的，因为很多工作都由框架自动完成。基于你提供的<code>AccountDao</code>接口，我将提供一系列步骤来说明如何创建这种DAO：</p>
<ol>
<li><p><strong>设置Spring Boot项目</strong>:<br>如果你还没有设置Spring Boot项目，你可以使用<a target="_blank" rel="noopener" href="https://start.spring.io/">Spring Initializr</a>来创建一个，并在其中包括<code>Spring Web</code>和<code>Spring Data JPA</code>的依赖。</p>
</li>
<li><p><strong>配置数据库连接</strong>:<br>在<code>src/main/resources/application.properties</code>文件中，你需要配置数据库连接。例如，对于MySQL数据库，配置可能如下：</p>
</li>
</ol>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mydb</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">myuser</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">mypassword</span></span><br><span class="line"><span class="attr">spring.jpa.hibernate.ddl-auto</span>=<span class="string">update</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>定义实体类</strong> (<code>AccountEntity</code>):<br>根据你的DAO接口，似乎已经存在一个<code>AccountEntity</code>类。确保它使用JPA注解正确地标注，例如<code>@Entity</code>, <code>@Table</code>, <code>@Id</code>等。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountEntity</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String accountName;</span><br><span class="line">    <span class="keyword">private</span> String accountEmail;</span><br><span class="line">    <span class="keyword">private</span> String accountPassword;</span><br><span class="line">    <span class="comment">// getters, setters, etc.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>定义DAO接口</strong>:<br>如你所提供，直接创建一个接口<code>AccountDao</code>，它继承自<code>JpaRepository</code>。指定的方法名应遵循Spring Data JPA的命名约定。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;AccountEntity, Long&gt; &#123;</span><br><span class="line">    AccountEntity <span class="title function_">findByAccountName</span><span class="params">(String accountName)</span>;</span><br><span class="line">    AccountEntity <span class="title function_">findByAccountEmailAndPassword</span><span class="params">(String email, String password)</span>;</span><br><span class="line">    AccountEntity <span class="title function_">findByAccountNameAndPassword</span><span class="params">(String name, String password)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>使用DAO</strong>:<br>无需为<code>AccountDao</code>接口提供实现。Spring Data JPA在运行时会自动为你提供实现。你只需要在服务或控制器中注入<code>AccountDao</code>，并使用它：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AccountEntity <span class="title function_">findByName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findByAccountName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... other methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>启动应用程序</strong>:<br>启动你的Spring Boot应用程序，Spring Data JPA将自动为<code>AccountDao</code>接口生成实现，并与数据库进行交互。</li>
</ol>
<p>总的来说，使用Spring Data JPA可以极大地简化数据访问代码，因为你不需要手动编写实现或查询。只要正确地命名方法并设置相关的JPA注解，框架就会为你处理大部分工作。</p>
<p>在Spring Data JPA中，当你的DAO接口继承了<code>JpaRepository</code>或其他Spring Data JPA提供的接口，一些基本的CRUD方法（如<code>save</code>, <code>findAll</code>, <code>findById</code>, <code>delete</code>等）已经隐式地为你提供了实现。这意味着，你实际上不需要手动实现这些方法。</p>
<p>对于<code>save(AccountEntity accountEntity)</code>这个方法，只要你在DAO接口中声明它，Spring Data JPA会在运行时为你提供实现。</p>
<p>以下是一些简单的步骤：</p>
<ol>
<li><strong>声明方法</strong>:<br>在你的DAO接口中，只需声明<code>save</code>方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;AccountEntity, Long&gt; &#123;</span><br><span class="line">    AccountEntity <span class="title function_">save</span><span class="params">(AccountEntity accountEntity)</span>;</span><br><span class="line">    <span class="comment">// ... other methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>使用方法</strong>:<br>在你的Service类或其他需要使用的地方，你可以注入<code>AccountDao</code>，然后直接调用<code>save</code>方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AccountEntity <span class="title function_">createOrUpdateAccount</span><span class="params">(AccountEntity account)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.save(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... other methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>实际运行</strong>:<br>当你实际运行你的应用程序并调用<code>save</code>方法时，Spring Data JPA会自动为你处理这个方法的实现。如果<code>AccountEntity</code>有一个ID并且这个ID在数据库中已经存在，它会执行更新操作；如果<code>AccountEntity</code>没有ID或ID在数据库中不存在，它会执行插入操作。</li>
</ol>
<p>总之，使用Spring Data JPA的一个主要好处是它为常见的数据库操作提供了自动化的实现，所以你不需要手动编写这些操作的代码。</p>
<p>在Spring和许多其他软件框架中，”service”通常指的是应用程序中的业务逻辑层。这一层位于数据访问层（如DAO）和表示层（如控制器或UI）之间，负责处理应用程序的主要业务流程和操作。</p>
<p>以下是关于”service”的详细描述：</p>
<ol>
<li><p><strong>定义</strong>：</p>
<ul>
<li>Service层主要负责业务逻辑的实现。它处理应用程序的核心功能，并与DAO层交互以获取和存储数据。</li>
<li>通常，Service层将是无状态的，这意味着它不会存储有关特定用户或会话的信息。相反，它接受请求、处理它，并返回结果。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li>数据验证和处理：Service层经常负责验证传入的数据，确保它们满足业务规则。</li>
<li>事务管理：在需要多个数据库操作来完成一个业务操作的情况下，Service层通常负责事务的管理。</li>
<li>缓存：为了提高性能，某些业务操作可能会涉及缓存，Service层可以管理这些缓存。</li>
<li>调用其他服务：在微服务架构中，一个服务可能需要调用另一个服务，Service层是这种调用的好地方。</li>
</ul>
</li>
<li><p><strong>与DAO的区别</strong>：</p>
<ul>
<li>DAO层主要关心数据的获取和存储，而不关心业务逻辑。</li>
<li>Service层主要处理业务逻辑，并调用DAO层来访问数据。</li>
</ul>
</li>
<li><p><strong>Spring中的Service</strong>：</p>
<ul>
<li>在Spring中，Service层通常由使用<code>@Service</code>注解的类表示。这使得Spring可以自动检测和管理这些类作为beans。</li>
<li>Service类通常会使用<code>@Autowired</code>或构造函数注入来获得所需的DAO或其他Service。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountService</span><span class="params">(AccountDao accountDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AccountEntity <span class="title function_">createOrUpdateAccount</span><span class="params">(AccountEntity account)</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑，例如验证账户信息等</span></span><br><span class="line">        <span class="keyword">return</span> accountDao.save(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... other business methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>测试</strong>：<ul>
<li>为了保证Service层的业务逻辑正确，通常会为其编写单元和集成测试。</li>
<li>在测试Service层时，常常会使用模拟（Mock）对象模拟DAO层或其他外部依赖，以确保测试仅关注业务逻辑。</li>
</ul>
</li>
</ol>
<p>总的来说，Service层是应用程序的核心，它处理应用程序的主要业务逻辑，与数据访问层和表示层交互，确保数据的正确性和业务流程的正确性。</p>
<p><code>JDBC</code>、<code>ORM</code> 和 <code>JPA</code> 在 Java 数据库交互领域中有不同的层次和角色。它们之间的关系可以从以下几个方面来理解：</p>
<ol>
<li><p><strong>基础到高级</strong>:</p>
<ul>
<li><strong>JDBC</strong>: 这是 Java 与数据库交互的基础层。JDBC 提供了一组接口和类，使 Java 应用程序能够与各种关系数据库进行通信。</li>
<li><strong>ORM</strong>: 这是在 JDBC 之上的一种技术抽象，旨在提供对象与数据库之间的映射，使程序员可以用面向对象的方式操作数据库。</li>
<li><strong>JPA</strong>: 是 ORM 的一种规范。它并不直接提供 ORM 功能，而是定义了如何进行 ORM。实际的 ORM 功能由遵循 JPA 规范的提供者（如 Hibernate、EclipseLink 等）实现。</li>
</ul>
</li>
<li><p><strong>实现关系</strong>:</p>
<ul>
<li>虽然 ORM 工具（如 Hibernate）可能提供自己的 API 来与数据库交互，但在底层，它们通常使用 JDBC 进行实际的数据库操作。</li>
<li>JPA 只是一个规范，而不是实际的实现。例如，Hibernate 不仅是一个 ORM 工具，还是 JPA 的一个实现。</li>
</ul>
</li>
<li><p><strong>功能与抽象层次</strong>:</p>
<ul>
<li><strong>JDBC</strong>: 与数据库的交互是明确且显式的，涉及明确的 SQL 语句和数据库操作。</li>
<li><strong>ORM</strong>: 允许更抽象的数据库操作，其中 SQL 通常是隐式生成的，并且程序员主要与对象和类而不是直接的数据库表和查询进行交互。</li>
<li><strong>JPA</strong>: 为 ORM 提供了一个标准化的方法，这意味着在理论上，您可以将一个 JPA 实现（例如 Hibernate）替换为另一个（例如 EclipseLink），而不必大量更改代码。</li>
</ul>
</li>
</ol>
<p>综上所述，<code>JDBC</code>、<code>ORM</code> 和 <code>JPA</code> 在 Java 数据库交互领域中有不同的关系和作用。JDBC 是基础，而 ORM 和 JPA 提供了不同层次的抽象和标准化，使得数据库操作更加简洁和高效。</p>
<p><code>ssh: connect to host github.com port 22: Connection timed out</code> 错误意味着您在尝试通过SSH端口（即端口22）连接到github.com时遇到了问题。这可能是由于多种原因造成的，以下是一些建议的解决方法：</p>
<ol>
<li><p><strong>检查网络连接</strong>：</p>
<ul>
<li>确保您的互联网连接正常。</li>
<li>如果您处于公司或学校网络，SSH端口可能被阻止。您可能需要与网络管理员联系以获取更多信息。</li>
</ul>
</li>
<li><p><strong>使用HTTPS而不是SSH</strong>：</p>
<ul>
<li>GitHub同时支持SSH和HTTPS进行代码推送和拉取。如果您无法通过SSH连接，尝试使用HTTPS。为此，您需要将远程URL从SSH更改为HTTPS。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin https://github.com/username/repo.git</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>使用其他SSH端口</strong>：</p>
<ul>
<li>GitHub支持SSH通过端口22和443。如果您的网络阻止了端口22，尝试使用端口443。<ul>
<li>为此，您可以编辑您的<code>~/.ssh/config</code>文件（如果它不存在，您可以创建一个）并添加以下内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  Hostname ssh.github.com</span><br><span class="line">  Port 443</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>测试SSH连接</strong>：</p>
<ul>
<li>您可以使用以下命令测试与GitHub的SSH连接：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<ul>
<li>如果连接成功，您应该会看到一条消息说您已经被认证。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>检查SSH密钥</strong>：</p>
<ul>
<li>确保您已将公钥添加到您的GitHub帐户，并且私钥在您的机器上。</li>
<li>您可以使用<code>ssh-add -l</code>检查已加载的SSH密钥。</li>
<li>如果需要，使用<code>ssh-add ~/.ssh/your-private-key</code>手动添加您的密钥。</li>
</ul>
</li>
<li><p><strong>代理或VPN</strong>：</p>
<ul>
<li>如果您正在使用代理或VPN，请尝试直接连接，看看问题是否仍然存在。</li>
</ul>
</li>
<li><p><strong>检查防火墙设置</strong>：</p>
<ul>
<li>确保您的防火墙或安全软件没有阻止SSH连接。</li>
</ul>
</li>
</ol>
<p>如果上述方法都不能解决问题，您可能需要进一步诊断网络问题或与您的网络服务提供商联系。</p>
<p>如果你遇到 “ssh: connect to host github.com port 22: Connection timed out” 错误，表示你在尝试连接到 GitHub 的时候遇到了问题。下面是一些可能的解决方案：</p>
<ol>
<li><p><strong>使用其他SSH端口</strong>：<br>GitHub 同时支持端口22和443。你可以试着用443端口连接到GitHub。</p>
<ul>
<li>为此，你需要编辑你的 <code>~/.ssh/config</code> 文件（如果没有，就创建一个），然后添加以下内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  Hostname ssh.github.com</span><br><span class="line">  Port 443</span><br></pre></td></tr></table></figure></li>
<li>保存文件并再次尝试 <code>ssh -T git@github.com</code>。</li>
</ul>
</li>
<li><p><strong>切换到HTTPS</strong>：<br>如果SSH连接仍然有问题，你可以考虑使用HTTPS而不是SSH来与GitHub通信。</p>
<ul>
<li>更改你的远程URL从SSH到HTTPS：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin https://github.com/username/repo.git</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>检查网络设置</strong>：</p>
<ul>
<li>有些网络环境（如学校、公司或特定的国家&#x2F;地区）可能会阻止特定的端口连接，特别是端口22。</li>
<li>如果你使用的是公司或学校网络，请询问网络管理员是否SSH端口（22）被阻止了。</li>
<li>如果你使用的是家庭网络，你可以登录到路由器的后台，查看是否有端口阻止或者其他相关的安全设置。</li>
</ul>
</li>
<li><p><strong>使用VPN</strong>：<br>在某些地方，直接的SSH连接可能会受到ISP或国家政策的影响。在这种情况下，使用VPN可以帮助绕过这些限制。</p>
</li>
<li><p><strong>防火墙和安全软件</strong>：<br>请检查你的操作系统的防火墙设置，以确保没有阻止SSH的出站连接。如果你有其他的安全软件或防病毒软件，请检查它们的设置，确保它们没有阻止SSH连接。</p>
</li>
<li><p><strong>重新生成和添加SSH密钥</strong>：</p>
<ul>
<li>检查你的SSH密钥是否已经添加到GitHub。如果没有，你可以重新生成一个新的SSH密钥，并将其添加到你的GitHub帐户。</li>
<li>使用命令 <code>ssh-keygen</code> 生成一个新的密钥。</li>
<li>将公钥（通常是 <code>~/.ssh/id_rsa.pub</code>）添加到你的GitHub帐户中。</li>
</ul>
</li>
<li><p><strong>网络诊断工具</strong>：<br>使用 <code>ping</code>, <code>traceroute</code> 或 <code>tracert</code>（Windows上）等工具来检查与github.com的网络连接路径，这可以帮助你诊断连接问题的根源。</p>
</li>
</ol>
<p>如果尝试了上述所有建议都没有成功，你可能需要进一步深入了解你的网络环境，或者与网络服务提供商联系。</p>
<p>从你的 <code>ping</code> 结果来看，你无法成功地与 <code>github.com</code> 建立连接。这意味着网络通信被某种方式阻断了。</p>
<p>以下是几种可能的原因和相应的解决办法：</p>
<ol>
<li><p><strong>网络问题</strong>：你当前所在的网络可能有问题，或者与GitHub服务器之间的通信路径有问题。你可以试着重启路由器或切换到另一个网络（例如使用移动数据）来进行测试。</p>
</li>
<li><p><strong>ISP 限制</strong>：某些互联网服务提供商可能会限制访问某些网站或服务，尤其是在某些国家或地区。在这种情况下，你可以考虑使用VPN或代理来绕过这些限制。</p>
</li>
<li><p><strong>本地防火墙</strong>：你的操作系统的防火墙或安全软件可能阻止了与GitHub的通信。请检查并确保没有任何规则阻止访问 <code>github.com</code>。</p>
</li>
<li><p><strong>路由器&#x2F;硬件防火墙</strong>：如果你在公司、学校或公共网络上，网络硬件可能设置了访问限制。与网络管理员沟通以获得更多信息。</p>
</li>
<li><p><strong>DNS问题</strong>：虽然不太可能，但DNS解析问题可能会导致连接问题。尝试更改你的DNS服务器到8.8.8.8（Google的公共DNS）或1.1.1.1（Cloudflare的DNS）。</p>
</li>
<li><p><strong>GitHub宕机或维护</strong>：这也是可能的，尽管很少发生。你可以查看 <a target="_blank" rel="noopener" href="https://www.githubstatus.com/">GitHub Status</a> 页面来检查GitHub的当前状态。</p>
</li>
</ol>
<p>解决此类问题可能需要一些技术知识和耐心。你可能需要多次尝试，或与网络专家或服务提供商沟通，以确定和解决问题。</p>
<p>确实，防火墙和其他安全软件可能会阻止或限制某些网络连接，尤其是SSH连接。为了确保你的SSH连接没有被阻止，你可以采取以下步骤来检查和调整你的防火墙设置：</p>
<ol>
<li><p><strong>Windows系统防火墙</strong>:</p>
<p>如果你使用的是Windows操作系统，你可以按照以下步骤检查防火墙设置：</p>
<ul>
<li>打开“控制面板”。</li>
<li>选择“系统和安全”。</li>
<li>点击“Windows Defender 防火墙”。</li>
<li>在左侧面板中，点击“高级设置”。</li>
<li>在出现的“Windows 防火墙和高级安全”窗口中，查看“出站规则”，确保没有阻止SSH的规则。</li>
<li>如果有任何阻止SSH或端口22的规则，考虑将其禁用或删除。</li>
</ul>
</li>
<li><p><strong>Mac系统防火墙</strong>:</p>
<p>如果你使用的是Mac操作系统，你可以按照以下步骤检查防火墙设置：</p>
<ul>
<li>打开“系统偏好设置”。</li>
<li>选择“安全性与隐私”。</li>
<li>转到“防火墙”选项卡。</li>
<li>点击“防火墙选项…”并确保没有阻止SSH的相关规则。</li>
</ul>
</li>
<li><p><strong>Linux系统防火墙</strong>:</p>
<p>在Linux系统上，你可能会使用<code>iptables</code>, <code>ufw</code>或其他防火墙管理工具。你需要根据你的系统和使用的防火墙工具相应地检查设置。例如，使用<code>ufw</code>时，你可以运行<code>sudo ufw status</code>来查看活跃的规则。</p>
</li>
<li><p><strong>其他安全软件</strong>:</p>
<p>如果你安装了其他安全软件或防病毒软件，它们可能也有自己的防火墙或网络访问控制功能。请查看这些软件的文档或设置，确保它们没有阻止SSH连接。</p>
</li>
</ol>
<p>进行上述检查后，如果你发现有任何可能与SSH连接相关的阻止规则，请考虑暂时禁用或修改它们，并尝试重新连接。如果问题解决，那么你可以考虑创建一个允许SSH连接的规则，以便在保持安全性的同时，仍然可以进行SSH连接。</p>
<ol start="2">
<li><p><strong>检查阻止SSH的规则</strong>：</p>
<ul>
<li>在“出站规则”列表中，查看是否有任何与SSH或端口22相关的规则。</li>
<li>你可以查看规则的“名称”，“协议”和“本地&#x2F;远程端口”列。如果你看到与SSH或端口22相关的规则，并且在“操作”列中标记为“阻止”，则该规则可能是导致问题的原因。</li>
<li>如果找到此类规则，你可以右键点击该规则并选择“属性”以查看更多详情。如果你确定该规则是问题所在，可以考虑禁用或删除它。</li>
</ul>
</li>
<li><p><strong>创建允许SSH的规则</strong>（如果需要）：</p>
<p>如果你没有找到与SSH相关的出站规则，但仍然遇到连接问题，可以考虑添加一个明确允许SSH连接的规则：</p>
<ul>
<li>在“出站规则”列表的右侧面板中，点击“新建规则…”。</li>
<li>选择“端口”，点击“下一步”。</li>
<li>选择“TCP”并输入“22”作为端口号。</li>
<li>在接下来的屏幕中，选择“允许连接”。</li>
<li>继续点击“下一步”并为新规则命名，例如“Allow SSH”。然后点击“完成”。</li>
</ul>
</li>
</ol>
<p>解决 IP 地址冲突问题需要确保在您的网络中每个设备都被分配了唯一的 IP 地址。以下是一些步骤可以帮助您解决这个问题：</p>
<ol>
<li><p><strong>查找冲突的设备</strong>:</p>
<ul>
<li>在您的局域网络中，查找可能分配了相同 IP 地址的设备。这些设备可能是计算机、移动设备、网络打印机等。</li>
</ul>
</li>
<li><p><strong>手动分配 IP 地址</strong>:</p>
<ul>
<li>在您的路由器设置中，可以选择手动分配 IP 地址。这又称为静态 IP 地址分配。通过将每个设备的 IP 地址设置为独特的值，可以防止冲突。通常，路由器的设置界面中会有一个区域用于设置静态 IP 地址。</li>
</ul>
</li>
<li><p><strong>使用 DHCP 保留</strong>:</p>
<ul>
<li>DHCP 保留是一种方法，可以将某个设备与一个特定的 IP 地址相关联。在路由器的 DHCP 设置中，您可以将设备的 MAC 地址与一个特定的 IP 地址关联起来，这样每次设备连接时，路由器都会为该设备分配保留的 IP 地址。</li>
</ul>
</li>
<li><p><strong>检查其他网络设备</strong>:</p>
<ul>
<li>确保您的网络中没有其他路由器、交换机或 DHCP 服务器在分配 IP 地址，这可能会导致冲突。</li>
</ul>
</li>
<li><p><strong>重新启动设备</strong>:</p>
<ul>
<li>如果您怀疑某个设备分配了相同的 IP 地址，尝试重新启动该设备。有时，重新启动可以解决冲突。</li>
</ul>
</li>
<li><p><strong>刷新 IP 地址</strong>:</p>
<ul>
<li>如果您的计算机已经分配了相同的 IP 地址，您可以尝试刷新 IP 地址。在 Windows 中，您可以使用以下命令来释放和续订 IP 地址：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /release</span><br><span class="line">ipconfig /renew</span><br></pre></td></tr></table></figure>
在 Linux 中，您可以使用以下命令：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dhclient -r</span><br><span class="line">sudo dhclient</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>解决 IP 地址冲突可能需要一些技术步骤，具体步骤可能因您所使用的路由器和操作系统而异。如果您对如何执行上述步骤感到不确定，建议您在需要时寻求网络管理员或技术支持的帮助。</p>
<p>非常抱歉之前的误解。如果您在命令提示符中尝试通过ping命令ping <a target="_blank" rel="noopener" href="http://www.google.com/">www.google.com</a> 失败，但可以通过ping命令ping 8.8.8.8成功，这可能涉及到DNS解析的问题。</p>
<p>下面是一些可能的解决方案：</p>
<ol>
<li><p><strong>DNS解析问题：</strong> 您的计算机可能无法正确解析域名。虽然ping 8.8.8.8可以成功，但这只是一个IP地址，而不是域名。尝试在命令提示符中运行以下命令，以查看是否可以正确解析域名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup www.google.com</span><br></pre></td></tr></table></figure>

<p>如果无法解析域名，可能是DNS设置不正确或者被限制导致的。您可以尝试更改DNS设置为一些公共DNS服务器，如Google的8.8.8.8或Cloudflare的1.1.1.1。</p>
</li>
<li><p><strong>DNS污染：</strong> 在一些地区，DNS可能受到干扰，导致无法正常解析特定的域名。这可能会影响某些域名的解析，但不影响其他域名。尝试在命令提示符中使用不同的域名，看看是否可以解析其他域名。</p>
</li>
<li><p><strong>Hosts文件问题：</strong> 检查一下您计算机的hosts文件是否有异常。hosts文件可以用来手动映射域名到IP地址，如果存在异常的映射可能导致无法访问特定的域名。</p>
</li>
<li><p><strong>VPN DNS设置：</strong> 检查您的VPN连接是否设置了自定义的DNS服务器。有些VPN会自动修改您的DNS设置，可能会导致解析问题。您可以尝试在连接VPN的同时手动设置DNS服务器。</p>
</li>
</ol>
<p>如果您尝试了上述方法仍然无法解决问题，建议您联系您的VPN提供商或网络管理员寻求进一步的帮助。</p>
<p>There was an unexpected error (type&#x3D;Method Not Allowed, status&#x3D;405).<br>这个错误 “Method Not Allowed” (方法不允许) 是由于在请求处理中使用了不支持的 HTTP 方法。通常情况下，这意味着你在你的控制器方法上使用了错误的 <code>@RequestMapping</code> 注解，或者你的表单提交的请求方法与控制器方法不匹配。</p>
<p>具体来说，当你在访问注册界面时，可能在表单提交时使用了不正确的请求方法，比如使用了 GET 方法，但你的控制器方法只支持 POST 方法。</p>
<p>以下是一个处理注册表单提交的示例代码，假设你的表单提交使用 POST 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> blog.com.ex.controllers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">showRegisterPage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register&quot;</span>; <span class="comment">// 返回注册页面的模板名称</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/register&quot;)</span> <span class="comment">// 注意这里使用了 POST 方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">processRegistration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 处理注册逻辑</span></span><br><span class="line">        <span class="comment">// 返回适当的页面，比如注册成功页面或错误页面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>showRegisterPage</code> 方法用于返回注册页面，这个方法使用了 GET 请求。而 <code>processRegistration</code> 方法用于处理注册表单的提交，这个方法使用了 POST 请求。</p>
<p>如果你的注册表单提交使用了 GET 方法，那么你需要将相应的控制器方法中的注解改为 <code>@GetMapping</code>。如果使用了 POST 方法，需要将注解改为 <code>@PostMapping</code>。</p>
<p>确保在表单提交和控制器方法之间使用相同的 HTTP 方法，这样可以避免 “Method Not Allowed” 错误。</p>
<p>提交 Maven Wrapper 文件到版本控制系统可能会导致团队中的开发人员在使用不同环境时遇到问题，主要是因为 Maven Wrapper 文件中包含了与环境相关的配置和设置。这可能导致以下几种情况：</p>
<ol>
<li><p><strong>不同操作系统的问题：</strong> Maven Wrapper 文件中的脚本和配置可能会因操作系统而异。例如，Windows 和类Unix系统的脚本语法可能不同，路径分隔符也可能不同。如果将特定于一个操作系统的 Maven Wrapper 文件提交到版本控制，其他开发人员在不同操作系统上使用时可能会遇到脚本执行问题。</p>
</li>
<li><p><strong>Maven 版本一致性：</strong> Maven Wrapper 文件中的配置会指定特定的 Maven 版本用于构建项目。如果一个开发人员在不同的 Maven 版本下进行构建，可能会导致构建结果不一致，甚至出现构建失败或错误。</p>
</li>
<li><p><strong>固定路径问题：</strong> Maven Wrapper 文件可能包含了与项目路径相关的信息，如果这些路径被提交到版本控制，其他开发人员的项目目录结构与提交者不同，就可能导致脚本执行失败。</p>
</li>
<li><p><strong>不必要的文件冲突：</strong> 如果多个开发人员在不同环境下生成了不同版本的 Maven Wrapper 文件，并将它们提交到版本控制，这可能会导致代码库中存在多个不同版本的文件，增加了冲突和维护的复杂性。</p>
</li>
</ol>
<p>为了避免这些问题，通常建议将 Maven Wrapper 文件添加到 <code>.gitignore</code> 文件中，以便每个开发人员可以在其本地环境中根据需要生成这些文件，确保在不同环境中构建的一致性和可重复性。这有助于简化团队协作和减少潜在的构建问题。</p>
<h1 id="Ignore-Maven-Wrapper-files"><a href="#Ignore-Maven-Wrapper-files" class="headerlink" title="Ignore Maven Wrapper files"></a>Ignore Maven Wrapper files</h1><p>.mvn&#x2F;wrapper&#x2F;<br>mvnw<br>mvnw.cmd</p>
<p>如果你只是删除了.mvn&#x2F;wrapper&#x2F;目录以及mvnw、mvnw.cmd等 Maven Wrapper 相关的文件，而保留了pom.xml中的Maven配置和其他必要的文件，那么理论上是可以的，因为pom.xml中的Maven配置可以指定所需的Maven版本以及其他构建设置。</p>
<p>在计算机安全领域中，”salt” 和 “pepper” 都是用来增加密码散列（hashing）安全性的术语。</p>
<ol>
<li><p><strong>Salt（盐）</strong>：盐是一个随机生成的字符串，与密码一起用于加密哈希算法。它的作用是为了防止彩虹表攻击（Rainbow Table Attack）。彩虹表是一种预先计算好的密码散列值与明文密码的对应表，攻击者可以通过对比这个表来破解密码。使用盐，可以确保即使两个用户使用相同的密码，其最终的哈希值也会不同，因为每个用户都有不同的盐。这增加了破解密码的难度。</p>
</li>
<li><p><strong>Pepper（胡椒粉）</strong>：胡椒粉与盐类似，但是不同之处在于它是一个全局的、秘密的、静态的字符串，而不是与用户密码关联的。胡椒粉通常在服务器端被应用于密码哈希之前，以增加密码散列的安全性。与盐不同，胡椒粉对于每个用户都是一样的，所以它不会在用户之间区分密码，而是提供了一个额外的层次的保护，以防止数据库泄露后的攻击。</p>
</li>
</ol>
<p>综合来说，盐和胡椒粉都是用来增加密码散列的安全性的技术，但它们的应用方式略有不同。使用适当的盐和&#x2F;或胡椒粉可以显著提高密码存储的安全性，降低攻击者破解密码的成功率。</p>
<p>当将测试分为三类时，通常可以按照以下方式划分：</p>
<ol>
<li><p><strong>静态测试（Static Testing）</strong>：这种类型的测试是在不实际执行代码的情况下进行的，主要关注于代码和文档的分析。它有助于发现潜在的问题和错误，以及确保代码的一致性和符合性。静态测试包括：</p>
<ul>
<li><strong>代码审查（Code Review）</strong>：开发人员对彼此的代码进行审查，以发现错误、改进代码质量，并确保代码遵循最佳实践。</li>
<li><strong>静态分析（Static Analysis）</strong>：使用自动化工具对代码进行分析，以检测潜在的错误、代码风格问题和安全漏洞。</li>
</ul>
</li>
<li><p><strong>动态测试（Dynamic Testing）</strong>：这种类型的测试是在实际执行代码的情况下进行的，旨在验证软件在运行时的行为。动态测试包括：</p>
<ul>
<li><strong>单元测试（Unit Testing）</strong>：测试单个代码单元，如函数或方法，以验证其功能是否正确。</li>
<li><strong>集成测试（Integration Testing）</strong>：测试不同单元之间的交互，确保它们在组合时能够正常工作。</li>
<li><strong>功能测试（Functional Testing）</strong>：验证软件的功能是否按照规格说明正常运行。</li>
<li><strong>性能测试（Performance Testing）</strong>：评估软件在不同负载下的性能表现。</li>
</ul>
</li>
<li><p><strong>非功能性测试（Non-functional Testing）</strong>：这种类型的测试关注软件的非功能性特征，如性能、安全性和可用性。非功能性测试包括：</p>
<ul>
<li><strong>性能测试（Performance Testing）</strong>：评估系统在各种负载条件下的性能表现。</li>
<li><strong>安全测试（Security Testing）</strong>：检查系统中的安全漏洞和弱点。</li>
<li><strong>兼容性测试（Compatibility Testing）</strong>：验证系统在不同环境中的兼容性。</li>
<li><strong>可用性测试（Usability Testing）</strong>：评估用户界面的易用性和用户体验。</li>
</ul>
</li>
</ol>
<p>这种三类划分提供了对不同测试类型的高级分类，有助于组织测试活动并确保全面覆盖软件质量方面的需求。</p>
<p>“白盒测试”、”灰盒测试”和”黑盒测试”是软件测试中常用的测试方法，它们基于测试者是否了解内部代码和系统结构的情况，可以按如下方式分类：</p>
<ol>
<li><p><strong>白盒测试（White Box Testing）</strong>：</p>
<ul>
<li>也称为结构测试或透明盒测试。</li>
<li>在这种测试中，测试人员了解被测试的代码、算法、数据结构以及内部逻辑。</li>
<li>白盒测试的目标是验证内部逻辑是否按照预期工作，是否正确执行，以及是否覆盖了所有可能的路径和分支。</li>
<li>常见的白盒测试方法包括语句覆盖、分支覆盖、路径覆盖等。</li>
</ul>
</li>
<li><p><strong>灰盒测试（Gray Box Testing）</strong>：</p>
<ul>
<li>灰盒测试介于白盒测试和黑盒测试之间。</li>
<li>在这种测试中，测试人员部分了解被测试系统的内部结构，但不需要详细了解所有细节。</li>
<li>灰盒测试的目标是结合对系统内部的一些了解，以及对用户需求和功能的了解，进行测试。</li>
<li>一个常见的应用是对系统的集成测试，其中可以根据系统的内部信息有针对性地选择测试用例。</li>
</ul>
</li>
<li><p><strong>黑盒测试（Black Box Testing）</strong>：</p>
<ul>
<li>也称为功能测试。</li>
<li>在这种测试中，测试人员不需要了解内部代码或系统结构，只关注输入和输出，以及系统的功能。</li>
<li>黑盒测试的目标是验证系统是否按照规格说明正常工作，而不考虑内部实现。</li>
<li>常见的黑盒测试方法包括等价类划分、边界值分析、场景测试等。</li>
</ul>
</li>
</ol>
<p>这些测试方法可以根据测试者是否了解系统内部来进行分类，每种方法都有其适用的场景和优势。通常，在实际测试中，不同的测试方法会结合使用，以确保对软件的不同方面进行全面测试。</p>
<p>单元测试是一种软件测试方法，旨在验证代码中最小可测试单元（通常是函数、方法或类）是否按照预期工作。以下是关于单元测试的一些重要信息：</p>
<ol>
<li><p><strong>目的</strong>：单元测试的主要目的是确保每个代码单元（最小功能块）的功能正确性。通过独立测试每个单元，可以在早期发现和修复问题，减少集成和系统测试阶段的错误。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>单元测试通常是自动化的，测试用例可以编写成代码，并由自动化测试框架运行。</li>
<li>单元测试是独立的，一个单元测试的失败不应该影响其他测试的运行。</li>
<li>单元测试通常是小规模的，关注代码的一个特定功能。</li>
<li>单元测试应该是可重复的，即无论何时运行，都应该得到相同的结果。</li>
</ul>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>提前发现问题：在代码编写过程中或后续的修改中，可以及早发现并修复问题，减少后期成本。</li>
<li>提高代码质量：通过频繁运行单元测试，鼓励开发人员编写更健壮、可靠的代码。</li>
<li>支持重构：在修改代码结构时，单元测试可以验证重构后的代码是否仍然正确。</li>
</ul>
</li>
<li><p><strong>流程</strong>：</p>
<ul>
<li>选择单元：选择要测试的单元，通常是函数、方法或类。</li>
<li>编写测试用例：为每个单元编写多个测试用例，以覆盖不同的输入情况和边界条件。</li>
<li>运行测试：使用单元测试框架运行测试用例，记录测试结果。</li>
<li>分析结果：检查测试结果，如果有失败的测试，确定问题的原因。</li>
<li>修复代码：在发现问题后，修改代码以解决问题，并确保测试通过。</li>
<li>循环重复：持续运行单元测试，确保代码的稳定性和可靠性。</li>
</ul>
</li>
</ol>
<p>单元测试在敏捷开发和持续集成等开发方法中具有重要作用，它有助于提供更快的反馈、更高的代码质量和更可靠的软件。</p>
<p>assertEquals：<br>JUnit 4或更高：<br>import org.junit.Test;<br>import static org.junit.Assert.assertEquals;<br>JUnit 5：<br>import org.junit.jupiter.api.Test;<br>import static org.junit.jupiter.api.Assertions.assertEquals;</p>
<p>EclEmma（也称为 EclEmma Java Code Coverage）是一个用于Eclipse集成开发环境（IDE）的插件，用于测量代码覆盖率。代码覆盖率是一个用来衡量测试是否覆盖了代码的度量指标，它显示了在测试运行期间代码的哪些部分被执行过（覆盖）以及哪些部分没有被执行过（未覆盖）。</p>
<p>EclEmma 提供了图形化的界面，帮助开发人员了解他们的测试用例在多大程度上覆盖了源代码。通过颜色编码的方式，EclEmma在源代码中标记已执行的代码（绿色）和未执行的代码（红色），以及部分执行的代码（黄色），从而帮助开发人员更直观地分析测试覆盖情况。</p>
<p>EclEmma 支持多种代码覆盖度的度量标准，包括：</p>
<ol>
<li><strong>语句覆盖率（Statement Coverage）</strong>：衡量已执行的语句占总语句数的比例。</li>
<li><strong>分支覆盖率（Branch Coverage）</strong>：衡量已执行的分支（如 if 语句的两个分支）占总分支数的比例。</li>
<li><strong>方法覆盖率（Method Coverage）</strong>：衡量已执行的方法占总方法数的比例。</li>
<li><strong>行覆盖率（Line Coverage）</strong>：衡量已执行的行数占总行数的比例。</li>
<li><strong>类覆盖率（Class Coverage）</strong>：衡量已执行的类占总类数的比例。</li>
</ol>
<p>使用 EclEmma，您可以更好地了解哪些部分的代码需要更多的测试用例来覆盖，以及哪些部分可能需要更多关注来提高代码质量。这有助于确保您的测试套件对代码的各个部分都进行了足够的测试，以降低潜在的缺陷风险。<br>在 IntelliJ IDEA 中，可以用 “Code Coverage” 功能来查看测试覆盖率并分析测试的效果。</p>
<p>使用了 @Data 注解，Lombok会自动生成 getters、setters、equals、hashCode 和 toString 方法，从而简化了代码。</p>
<p>@Test<br>public void testBuildAccount_InvaildUserName_Null() {<br>Account account &#x3D; demo.buildAccount(4L, “Ana”, “12345678”);<br>assertNull(account);}<br>写和不写assertNull(account);有啥区别</p>
<p>在此测试方法中，使用 <code>assertNull(account)</code> 验证 <code>account</code> 对象是否为 <code>null</code>。这个断言用于确保在测试中创建的 <code>account</code> 对象在 <code>buildAccount</code> 方法中没有被正确构建，预期它应该是 <code>null</code>。</p>
<p>如果不写 <code>assertNull(account)</code>，那么测试方法就不会对 <code>account</code> 进行任何断言，这意味着测试方法不会显式地验证 <code>account</code> 是否为 <code>null</code>。这将导致以下情况之一：</p>
<ol>
<li><p><strong>测试通过</strong>：如果 <code>buildAccount</code> 方法返回了一个非 <code>null</code> 的 <code>account</code> 对象，而测试方法没有进行断言验证，那么测试将会通过，即使实际上 <code>buildAccount</code> 方法的行为与预期不符。</p>
</li>
<li><p><strong>测试失败</strong>：如果 <code>buildAccount</code> 方法返回了一个 <code>null</code> 值，而测试方法没有进行断言验证，测试也会通过。这将掩盖了一个潜在的问题，因为测试方法没有检测到这个问题。</p>
</li>
</ol>
<p>在编写测试用例时，使用适当的断言是非常重要的，因为它们帮助您确保代码按预期工作，并捕捉潜在的问题。因此，编写 <code>assertNull(account)</code> 断言是推荐的做法，以确保在测试中验证 <code>buildAccount</code> 方法的行为是否与预期一致。如果测试通过，便可以确信在这种情况下 <code>buildAccount</code> 方法确实返回了 <code>null</code>，而不是其他意外情况。</p>

                    
          </div>
          <footer>
            
              
                  
                      
                              <div class="clearfix"></div>
          </footer>
        </div>
</article>


<!-- 是否开启评论？ -->


  <article id="post-Week-2-of-AWS" class="h-entry post" itemprop="blogPost" itemscope
  itemtype="https://schema.org/BlogPosting">
  
        <div class="post-content">
          <header>
            
              <div class="icon"></div>
              <time class="dt-published" datetime="2023-08-20T15:47:24.000Z"><a
                  href="/2023/08/20/Week-2-of-AWS/">
                  2023-08-20
                </a></time>
              
                
  
    <h1 class="title"><a href="/2023/08/20/Week-2-of-AWS/">Week 2 of AWS</a></h1>
  

          </header>
          <div class="e-content entry" itemprop="articleBody">
            
                  <span id="more"></span>
<p><strong>high availability and fault tolerance.</strong></p>
<h2 id="choose-a-Region"><a href="#choose-a-Region" class="headerlink" title="choose a Region"></a>choose a Region</h2><p><strong>Four key factors to choose a Region: Compliance, proximity, feature availability, and pricing.</strong></p>
<ol>
<li>Compliance with data governance and legal requirements:Depending on your company and location, you might need to run your data out of specific areas.</li>
<li>Proximity to your customers</li>
<li>Available services within a Region: feature availability: Sometimes the closest Region may not have all the AWS features you want.</li>
<li>Suppose that you are considering running applications in both the United States and Brazil. The way Brazil’s tax structure is set up, it might cost 50% more to run the same workload out of the São Paulo Region compared to the Oregon Region.</li>
</ol>
<h2 id="AZ"><a href="#AZ" class="headerlink" title="AZ"></a>AZ</h2><p>AWS calls a single data center or a group of data centers, an Availability Zone or AZ.Each Availability Zone is one or more discrete data centers with redundant power, networking, and connectivity.<br>AWS（Amazon Web Services）的基础架构设计:如何设计和实现其Regions和Availability Zones (AZs)以确保高可用性和容灾能力。简言之，AWS鼓励在多个AZs中运行应用，以确保即使一个AZ受到影响，应用仍然可以正常运行。</p>
<p>关于您的问题：“所以是不是同一个服务最好买2个ec2？”的答案是：<br><strong>是的</strong>，为了确保高可用性和容错能力，您应该考虑在至少两个不同的Availability Zones中运行两个或更多的EC2实例。这样，如果一个AZ发生故障或受到影响，其他的AZ中的实例仍然可以为用户提供服务。这不仅增加了冗余，而且还提供了容灾和故障恢复能力。<br>Running Amazon EC2 instances in multiple Availability Zones</p>
<h2 id="AZ-Region"><a href="#AZ-Region" class="headerlink" title="AZ &amp; Region"></a>AZ &amp; Region</h2><p>在AWS（Amazon Web Services）的上下文中，一个单独的数据中心或一个区域内的一组数据中心被称为”Availability Zone”（常简称为AZ）。</p>
<ol>
<li><p>**Availability Zone (AZ)**：这是AWS基础设施的一个关键部分，用于提供高可用性和容错能力。</p>
<ul>
<li>一个AZ可以是一个单独的数据中心，也可以是一个地理区域内的几个物理上接近的数据中心。</li>
<li>每个AZ都有独立的电源、网络、冷却系统等，从而确保它可以在其他AZs出现问题时独立运行。</li>
<li>不同的AZs之间有低延迟的网络连接，从而确保在一个AZ内的资源可以与另一个AZ内的资源快速互相通信。</li>
</ul>
</li>
<li><p><strong>Region</strong>：一个Region是AWS全球基础设施的一个地理区域。每个Region都包括两个或多个Availability Zones。</p>
<ul>
<li>例如：<code>us-east-1</code> 是北弗吉尼亚的一个Region，它包括多个AZs。</li>
<li>选择不同的Regions可以帮助您满足法规要求、降低延迟或提供距离用户更近的服务。</li>
</ul>
</li>
</ol>
<p>为了提供高可用性和容错能力，AWS鼓励用户在一个Region的多个AZs中分布式部署他们的应用和服务。这样，如果一个AZ出现问题，其他AZs仍然可以继续为用户提供服务。</p>
<h2 id="Edge-Locations"><a href="#Edge-Locations" class="headerlink" title="Edge Locations:"></a>Edge Locations:</h2><p>An edge location is a site that Amazon CloudFront uses to store cached copies of your content. </p>
<blockquote>
<p>未完</p>
</blockquote>

                    
          </div>
          <footer>
            
              
                  
                      
                              <div class="clearfix"></div>
          </footer>
        </div>
</article>


<!-- 是否开启评论？ -->


  <article id="post-note-230819" class="h-entry post" itemprop="blogPost" itemscope
  itemtype="https://schema.org/BlogPosting">
  
        <div class="post-content">
          <header>
            
              <div class="icon"></div>
              <time class="dt-published" datetime="2023-08-19T15:07:35.000Z"><a
                  href="/2023/08/19/note-230819/">
                  2023-08-19
                </a></time>
              
                
  
    <h1 class="title"><a href="/2023/08/19/note-230819/">note_230819</a></h1>
  

          </header>
          <div class="e-content entry" itemprop="articleBody">
            
                  <span id="more"></span>
<h2 id="spring-jpa-hibernate-ddl-auto"><a href="#spring-jpa-hibernate-ddl-auto" class="headerlink" title="spring.jpa.hibernate.ddl-auto"></a>spring.jpa.hibernate.ddl-auto</h2><p>在Java Spring框架中，<code>spring.jpa.hibernate.ddl-auto</code>是一个用于配置Hibernate自动化数据库表生成和更新的属性。Hibernate是一个在Java应用程序和数据库之间提供对象关系映射（ORM）的框架，它允许开发者使用面向对象的方式操作数据库。</p>
<p><code>spring.jpa.hibernate.ddl-auto</code>属性决定了在应用程序启动时Hibernate如何处理数据库表的创建和更新。它有以下几个可选值：</p>
<ol>
<li><p><code>none</code>：这是默认值，Hibernate不会自动创建或更新表结构。这意味着你需要手动创建数据库表，Hibernate不会干涉或更新表结构。</p>
</li>
<li><p><code>update</code>：Hibernate会检查应用程序的实体类和数据库表之间的差异，并尝试根据差异来更新数据库表结构。它会尝试保留现有的数据，但这种方式不适合在生产环境中使用，因为它可能会导致数据丢失或不一致。</p>
</li>
<li><p><code>create</code>：Hibernate会根据应用程序的实体类自动创建数据库表。如果表已经存在，它会首先删除现有的表再创建新表。这也不适合生产环境，因为它会导致数据丢失。</p>
</li>
<li><p><code>create-drop</code>：类似于<code>create</code>，但是在应用程序关闭时会删除数据库表，适用于开发和测试环境，但不适合生产环境。</p>
</li>
<li><p><code>validate</code>：Hibernate会校验实体类和数据库表之间的差异，如果存在差异则会抛出异常。</p>
</li>
</ol>
<p>选择合适的值取决于你的应用程序的开发阶段和部署环境。在开发和测试阶段，你可能会选择<code>update</code>或<code>create-drop</code>，以便自动处理表结构的更新或创建。在生产环境中，通常不建议使用自动表结构更新功能，而是手动管理数据库表结构的变更，以避免意外的数据丢失或不一致性。</p>
<h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>跨域问题是指在浏览器中运行的脚本（例如 JavaScript）试图通过XMLHttpRequest或Fetch等方式从不同源（域、协议或端口）的服务器获取数据时，会受到同源策略（Same-Origin Policy）的限制。为了确保安全性，浏览器限制了跨域请求的能力。</p>
<p>如果您的前端页面和后端服务位于不同的域名、协议或端口，您需要处理跨域请求。下面是一些常用的跨域解决方法：</p>
<ol>
<li><p><strong>CORS（跨源资源共享）：</strong></p>
<ul>
<li>CORS是一种由浏览器支持的机制，允许服务器声明哪些源被允许访问其资源。在后端服务器中配置适当的CORS头，以允许特定的域名、端口或协议访问资源。</li>
<li>在Spring Boot中，您可以使用 <code>@CrossOrigin</code> 注解来实现CORS配置。例如，在您的Controller类或方法上添加此注解即可： <code>@CrossOrigin(origins = &quot;http://yourfrontenddomain.com&quot;)</code>。</li>
</ul>
</li>
<li><p><strong>代理服务器：</strong></p>
<ul>
<li>使用代理服务器将前端请求转发到后端，这样请求就在同一个域上执行，从而避免了跨域问题。您可以在前端应用程序中配置代理设置，或者使用反向代理服务器（例如Nginx、Apache）来处理这种转发。</li>
</ul>
</li>
<li><p><strong>JSONP（仅限GET请求）：</strong></p>
<ul>
<li>JSONP是一种通过动态创建<code>&lt;script&gt;</code>标签来获取数据的方法，适用于仅限GET请求的情况。后端返回的数据会包裹在一个函数调用中，然后在前端通过回调函数来处理。</li>
</ul>
</li>
<li><p><strong>WebSocket：</strong></p>
<ul>
<li>如果您需要实时通信，WebSocket是一种不受同源策略限制的协议。您可以考虑使用WebSocket来进行跨域通信。</li>
</ul>
</li>
</ol>
<p>在处理跨域问题时，需要确保前端和后端都采取了适当的措施。具体的解决方法取决于您的架构和需求。如果您仍然遇到问题，您可以查看浏览器的开发者工具控制台，通常会显示有关跨域问题的错误信息，从而帮助您进一步调试。</p>
<h2 id="JDBC-JPA"><a href="#JDBC-JPA" class="headerlink" title="JDBC &amp; JPA"></a>JDBC &amp; JPA</h2><p>JDBC（Java Database Connectivity）和JPA（Java Persistence API）都是Java中用于处理数据库操作的技术，但它们在实现方式和使用上有一些区别。</p>
<p><strong>JDBC（Java Database Connectivity）：</strong></p>
<ul>
<li><p><strong>定义：</strong> JDBC是Java标准库中的API，用于与关系型数据库进行交互。它提供了一组类和方法，使开发人员能够建立数据库连接、执行SQL查询和更新操作、处理结果集等。</p>
</li>
<li><p><strong>使用：</strong> 在使用JDBC时，你需要手动编写SQL语句、打开和关闭数据库连接、处理SQL异常等。这意味着你需要处理更多的底层细节。</p>
</li>
<li><p><strong>灵活性：</strong> JDBC提供了较高的灵活性，可以完全控制SQL语句的编写和数据库连接的管理。这对于需要处理复杂SQL查询和特定数据库操作的情况非常有用。</p>
</li>
</ul>
<p><strong>JPA（Java Persistence API）：</strong></p>
<ul>
<li><p><strong>定义：</strong> JPA是Java EE标准中的一部分，它是用于管理Java对象和关系型数据库之间映射的API。JPA的目标是提供一种更高层次的抽象，让开发人员能够通过面向对象的方式进行数据库操作，而不必关心底层的SQL语句。</p>
</li>
<li><p><strong>使用：</strong> 使用JPA时，你将定义实体类来映射数据库表，并使用JPA提供的注解或XML配置来指定映射关系。JPA会自动为你生成适当的SQL语句，执行数据库操作。</p>
</li>
<li><p><strong>抽象性：</strong> JPA提供了更高的抽象性，让开发人员能够更专注于领域模型而不必关心具体的SQL语句和数据库连接管理。这对于大部分的CRUD操作非常方便。</p>
</li>
</ul>
<p><strong>选择：</strong></p>
<ul>
<li><p>如果你需要对数据库操作有更精细的控制，需要编写复杂的SQL查询，或者与非关系型数据库交互，JDBC可能更适合你。</p>
</li>
<li><p>如果你想要更快速地进行数据库操作，专注于领域模型设计，而不必关心底层的数据库细节，JPA可能更适合你。</p>
</li>
</ul>
<p>同时，还有一个中间选项，即使用Spring的JdbcTemplate，它在JDBC的基础上提供了更方便的API，但仍然需要手动编写SQL语句。这取决于你的项目需求和个人偏好，可以选择适合你的数据库操作技术。</p>
<h2 id="Hutool"><a href="#Hutool" class="headerlink" title="Hutool"></a>Hutool</h2><p>Hutool（也称为HuTool）是一个Java编程工具包，旨在为Java开发人员提供一组功能丰富且易于使用的工具，以简化常见的编程任务。Hutool旨在填补Java标准库中缺失的一些功能，同时提供更简洁的API来增强开发效率。</p>
<p>以下是Hutool提供的一些功能和特性：</p>
<ol>
<li><p><strong>字符串处理：</strong> 提供了各种字符串处理工具，包括判断字符串为空、去除首尾空白字符、驼峰命名转换、字符串模板等。</p>
</li>
<li><p><strong>集合工具：</strong> 提供了一系列集合相关的工具，如集合合并、集合是否为空判断、集合类型转换等。</p>
</li>
<li><p><strong>日期时间工具：</strong> 提供了日期时间格式化、解析、计算等工具，支持常见的日期时间操作。</p>
</li>
<li><p><strong>文件操作：</strong> 提供了文件读写、拷贝、删除、压缩等功能。</p>
</li>
<li><p><strong>加密解密：</strong> 支持常见的加密解密算法，如MD5、SHA-256、Base64等。</p>
</li>
<li><p><strong>网络工具：</strong> 提供HTTP客户端、IP工具、URL解析等功能。</p>
</li>
<li><p><strong>正则表达式工具：</strong> 封装了正则表达式的常用操作，使其更易于使用。</p>
</li>
<li><p><strong>图片处理：</strong> 提供了图片缩放、水印添加等图片处理功能。</p>
</li>
<li><p><strong>IoC容器：</strong> 提供简单的IoC容器功能，用于管理Bean的创建和生命周期。</p>
</li>
<li><p><strong>等等…</strong> Hutool还提供了很多其他实用的工具，包括反射、对象克隆、随机数生成、XML处理等。</p>
</li>
</ol>
<p>总之，Hutool是一个非常实用的Java工具包，它可以帮助开发人员在日常开发中减少重复的编码工作，提高效率。你可以在项目中引入Hutool依赖，然后使用其提供的API来简化和加速开发过程。Hutool的官方网站提供了详细的文档和示例，可以帮助你更好地了解和使用它。</p>
<h2 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h2><p>MyBatis-Plus是基于MyBatis的增强工具库，它内部已经集成了MyBatis的核心功能，因此在使用MyBatis-Plus时，你不需要显式地添加MyBatis的依赖，只需要添加MyBatis-Plus的依赖即可。</p>
<p>MyBatis-Plus是一个基于MyBatis的增强工具库，它提供了许多便捷的功能来简化数据库访问层的开发，让你能更快速、高效地操作数据库。以下是MyBatis-Plus可以做的一些事情：</p>
<ol>
<li><p><strong>简化CRUD操作：</strong> MyBatis-Plus可以自动生成常见的增删改查操作，你只需要编写实体类和Mapper接口，MyBatis-Plus会帮你生成相应的SQL语句和方法。</p>
</li>
<li><p><strong>分页查询：</strong> MyBatis-Plus提供了内置的分页查询功能，你可以轻松地实现分页查询操作，不需要手动编写分页逻辑。</p>
</li>
<li><p><strong>条件构造器：</strong> MyBatis-Plus的条件构造器功能允许你根据条件动态生成查询条件，而无需手动编写复杂的SQL语句。这使得你能够更灵活地构建查询。</p>
</li>
<li><p><strong>自动填充：</strong> MyBatis-Plus支持自动填充功能，你可以在实体类中定义字段的自动填充逻辑，例如创建时间、更新时间等。</p>
</li>
<li><p><strong>乐观锁支持：</strong> MyBatis-Plus提供了对乐观锁的支持，让你可以更方便地实现乐观锁的机制来处理并发更新。</p>
</li>
<li><p><strong>通用Service层封装：</strong> MyBatis-Plus提供了通用的Service层封装，简化了一些常见的业务逻辑操作，如批量插入、批量更新等。</p>
</li>
<li><p><strong>代码生成器：</strong> MyBatis-Plus还内置了一个代码生成器，可以根据数据库表结构自动生成实体类、Mapper接口等代码，加速项目开发。</p>
</li>
<li><p><strong>动态表名和字段名：</strong> MyBatis-Plus支持在运行时动态设置表名和字段名，适用于一些需要根据条件切换表名的场景。</p>
</li>
<li><p><strong>多租户支持：</strong> MyBatis-Plus提供了多租户隔离的支持，可以轻松实现在一个数据库中管理多个租户的数据。</p>
</li>
<li><p><strong>Wrapper查询：</strong> MyBatis-Plus的Wrapper查询功能允许你以更灵活的方式构建复杂的查询条件，支持链式操作。</p>
</li>
</ol>
<p>总之，MyBatis-Plus旨在提高开发人员在数据库访问层的开发效率，减少重复性工作，同时提供了一些方便的功能来处理数据库操作中的常见问题。如果你在项目中使用MyBatis作为ORM框架，并希望简化和加速数据库访问层的开发，MyBatis-Plus是一个很好的选择。</p>
<h2 id=""><a href="#" class="headerlink" title="#!"></a>#!</h2><p>“#!” 是一种在网页开发中常见的符号，被称为 “hashbang” 或 “shebang”。在网页链接中使用 “#!” 时，通常表示这个链接是由 JavaScript 处理的，而不是传统的网页导航链接。</p>
<p>在您提供的 HTML 代码 <code>&lt;a href=&quot;#!&quot; class=&quot;text-white-50 fw-bold&quot;&gt;新規登録&lt;/a&gt;</code> 中，这个链接可能会通过 JavaScript 触发某种交互式操作，例如弹出注册表单、打开模态窗口或执行其他动态内容加载操作。具体操作将取决于 JavaScript 代码的实现。</p>
<p>总之，”#!” 在链接中通常表示链接会触发一些 JavaScript 行为，而不会导航到新的页面。如果您需要更<br>具体的信息，您可能需要查看网页的 JavaScript 代码来了解这个链接的实际作用。</p>
<h2 id="varying"><a href="#varying" class="headerlink" title="varying"></a>varying</h2><p>在数据库中，”varying” 通常是 “VARCHAR” 的缩写，表示可变长度的字符串数据类型。在一些数据库系统中，特别是早期的一些系统，”VARCHAR” 数据类型可能被缩写为 “VARYING”。</p>
<p>“VARCHAR” 表示可变长度字符数据类型，它允许存储不同长度的字符串。相对于固定长度的字符数据类型（如 “CHAR”），”VARCHAR” 可以节省存储空间，因为它只会占用实际存储的字符数量加上一些额外的字节来表示字符串的长度。</p>
<p>在现代数据库系统（如 PostgreSQL、MySQL、Oracle 等）中，”VARCHAR” 是一个常见的用于存储字符串数据的数据类型，而 “VARYING” 这个术语在更早的数据库系统中使用较多，现在逐渐被统一为 “VARCHAR”。因此，你可以将 “VARCHAR” 视为 “VARYING” 的现代等效术语。</p>
<h2 id="COLLATE-pg-catalog-”default”"><a href="#COLLATE-pg-catalog-”default”" class="headerlink" title="COLLATE pg_catalog.”default”"></a>COLLATE pg_catalog.”default”</h2><p>account_name character varying(255) COLLATE pg_catalog.”default”,<br>使用 <code>COLLATE pg_catalog.&quot;default&quot;</code> 或其他排序规则通常取决于以下情况：</p>
<ol>
<li><p><strong>多语言支持</strong>：如果你的应用程序需要处理多种语言的文本数据，不同语言可能有不同的排序方式。在这种情况下，你可以根据特定的语言和地区选择适当的排序规则，以确保数据在排序和比较时得到正确的结果。</p>
</li>
<li><p><strong>国际化应用程序</strong>：当你开发面向全球用户的应用程序时，不同地区和文化可能使用不同的字符排序规则。为了确保你的应用程序在各种环境下都能正确处理文本数据，你可以选择适当的排序规则。</p>
</li>
<li><p><strong>数据库迁移</strong>：如果你正在迁移数据库到另一个环境，例如从一个地区迁移到另一个地区，那么目标地区可能使用不同的排序规则。在这种情况下，你可能需要更新原始数据库的排序规则以适应新的环境。</p>
</li>
<li><p><strong>特定排序需求</strong>：有些情况下，你可能需要自定义的排序规则来满足特定需求，例如特定的应用程序逻辑或业务规则。</p>
</li>
</ol>
<p>总之，使用特定的排序规则取决于你的应用程序需求和数据库环境。如果你需要确保文本数据在排序和比较时得到一致的结果，可以选择适当的排序规则，如 <code>COLLATE pg_catalog.&quot;default&quot;</code>，以满足你的需求。</p>
<h2 id="一个合并冲突的报错-git"><a href="#一个合并冲突的报错-git" class="headerlink" title="一个合并冲突的报错 git"></a>一个合并冲突的报错 git</h2><p>您尝试进行 <code>git pull</code> 操作时，出现了一个合并冲突的错误。错误信息中提到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error: Your local changes to the following files would be overwritten by merge:</span><br><span class="line">        README.md</span><br><span class="line">Please commit your changes or stash them before you merge.</span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure>

<p>这意味着在您的本地仓库中，<code>README.md</code> 文件有未提交的更改。在进行 <code>git pull</code> 操作时，远程仓库中的更改与本地未提交的更改发生了冲突，因此 Git 阻止了合并操作。</p>
<p>您需要在继续进行 <code>git pull</code> 操作之前，解决这个合并冲突。以下是一些可能的解决步骤：</p>
<ol>
<li><p><strong>提交本地更改：</strong> 如果您的 <code>README.md</code> 文件中的更改是您想要保留的，您可以先使用 <code>git add README.md</code> 和 <code>git commit -m &quot;Your commit message&quot;</code> 命令将更改提交到本地仓库。然后再尝试进行 <code>git pull</code>。</p>
</li>
<li><p><strong>暂存本地更改：</strong> 如果您的 <code>README.md</code> 文件中的更改还没有准备好提交，您可以使用 <code>git stash</code> 命令将这些更改暂时存储起来，然后再进行 <code>git pull</code>。之后可以使用 <code>git stash apply</code> 或 <code>git stash pop</code> 将暂存的更改重新应用到您的工作目录中。</p>
</li>
<li><p><strong>丢弃本地更改：</strong> 如果您不需要保留 <code>README.md</code> 文件中的本地更改，您可以使用 <code>git checkout -- README.md</code> 命令来丢弃这些更改，然后再进行 <code>git pull</code>。</p>
</li>
</ol>
<p>无论您选择哪种解决方法，都要确保在进行 <code>git pull</code> 操作之前解决了合并冲突，以避免可能导致更多问题的情况发生。</p>
<h2 id="character-varying-和-int"><a href="#character-varying-和-int" class="headerlink" title="character varying 和 int"></a>character varying 和 int</h2><p>password character varying(255) COLLATE pg_catalog.”default”,<br>为啥是character varying而不是int<br><code>character varying</code> 和 <code>int</code> 是两种完全不同的数据类型，适用于不同类型的数据。选择使用哪种数据类型取决于你要存储的数据的性质和用途。</p>
<ol>
<li><p><strong>character varying</strong>: 这是一个用于存储字符串数据（文本）的数据类型。如果你需要存储像名称、描述、地址等文本信息，那么 <code>character varying</code> 是一个合适的选择。这个类型允许存储可变长度的字符串，根据实际数据的长度进行分配。</p>
</li>
<li><p><strong>int</strong>: 这是一个整数数据类型。如果你要存储数值，如计数、年龄、分数等，那么 <code>int</code> 是更适合的选项。整数类型通常用于表示没有小数部分的数字。</p>
</li>
</ol>
<p>所以，选择使用 <code>character varying</code> 还是 <code>int</code> 取决于你要存储的数据类型。如果你需要存储字符数据，如用户名、密码、说明等，那么 <code>character varying</code> 是正确的选择。如果你要存储数值数据，如计数器、标识符等，那么 <code>int</code> 是适合的选择。</p>
<p>为啥是character varying而不是CHAR<br><code>CHAR</code> 和 <code>character varying</code>（也称为 <code>VARCHAR</code>）是数据库中用于存储字符串数据的两种不同类型。它们的主要区别在于存储方式和处理空间的方式。</p>
<ol>
<li><p><strong>CHAR</strong>: <code>CHAR</code> 是一种固定长度的字符数据类型。无论实际存储的字符串长度是多少，<code>CHAR</code> 字段总是会占用指定的固定存储空间。例如，一个 <code>CHAR(10)</code> 字段总是占用 10 个字符的存储空间，无论你实际存储的字符串长度是多少。这可能导致空间浪费，因为如果存储的字符串长度小于字段的最大长度，剩余的空间会被填充空格。</p>
</li>
<li><p><strong>character varying (VARCHAR)</strong>: <code>character varying</code> 或 <code>VARCHAR</code> 是一种可变长度的字符数据类型。它会根据实际存储的字符串长度来分配存储空间，避免了不必要的空间浪费。例如，一个 <code>VARCHAR(255)</code> 字段只会占用实际存储的字符串长度所需的存储空间。</p>
</li>
</ol>
<p>选择 <code>character varying</code> 而不是 <code>CHAR</code> 可能有以下原因：</p>
<ul>
<li><p><strong>节省空间</strong>：<code>VARCHAR</code> 可以节省存储空间，因为它只会占用实际存储数据所需的空间，而不会填充多余的空格。</p>
</li>
<li><p><strong>灵活性</strong>：<code>VARCHAR</code> 允许存储不同长度的字符串，而 <code>CHAR</code> 则需要事先定义固定长度。</p>
</li>
<li><p><strong>避免填充字符</strong>：使用 <code>CHAR</code> 可能需要手动删除或处理存储的字符串中的额外空格，而 <code>VARCHAR</code> 不会在存储时填充字符。</p>
</li>
</ul>
<p>总之，选择 <code>CHAR</code> 还是 <code>VARCHAR</code> 取决于你的数据和应用程序的需求。如果你需要存储可变长度的字符串，避免空间浪费，并且更灵活地处理不同长度的文本，那么 <code>VARCHAR</code> 通常是更好的选择。</p>
<h2 id="character-varying和varying"><a href="#character-varying和varying" class="headerlink" title="character varying和varying"></a>character varying和varying</h2><p><code>character varying</code> 和 <code>varying</code> 都是数据库中用于定义可变长度字符串数据类型的关键词，但它们有一些细微的差别。</p>
<ol>
<li><p><strong>character varying</strong>: 这是 PostgreSQL 数据库中用于定义可变长度字符串的数据类型的关键词。它表示字段可以存储可变长度的字符数据，长度根据实际存储的数据来确定。在 PostgreSQL 中，<code>character varying</code> 可以缩写为 <code>varchar</code>。</p>
</li>
<li><p><strong>varying</strong>: 在一些其他数据库管理系统（DBMS）中，例如 Oracle 数据库，<code>varying</code> 可能被用作类似于 PostgreSQL 的 <code>character varying</code> 的关键词。它也表示可变长度的字符串数据类型。</p>
</li>
</ol>
<p>实际上，这两个关键词在不同的数据库系统中可能有不同的含义和用法。如果你正在使用 PostgreSQL，那么应该使用 <code>character varying</code> 或 <code>varchar</code> 来定义可变长度字符串。如果你使用其他 DBMS，你可能需要查阅该数据库的文档来了解正确的可变长度字符串数据类型的关键词是什么。</p>
<p>总之，<code>character varying</code> 和 <code>varying</code> 都表示可变长度字符串，但具体的用法和可用性可能因数据库系统而异。</p>
<p>CREATE TABLE user_accounts (<br>    account_id serial PRIMARY KEY,<br>    account_name varchar(255) NOT NULL,<br>    account_email varchar(255) NOT NULL,<br>    password varchar(255) NOT NULL<br>);<br>varchar是可变的，为啥还要加上255<br>你说得对，<code>VARCHAR</code> 数据类型本身就是可变长度的，不需要显式指定最大长度。我之前的回答中在创建表时给出了一个长度为 255 的示例，但实际上在大多数情况下，你可以不指定长度，或者根据你的需要选择一个适当的长度。感谢你的纠正。</p>
<p>在创建表时，以下示例展示了不指定长度的情况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_accounts (</span><br><span class="line">    account_id serial <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    account_name <span class="type">varchar</span>,</span><br><span class="line">    account_email <span class="type">varchar</span>,</span><br><span class="line">    password <span class="type">varchar</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>或者，如果你认为有一个合适的最大长度，你也可以在 <code>VARCHAR</code> 数据类型中指定一个适当的长度，比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_accounts (</span><br><span class="line">    account_id serial <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    account_name <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">    account_email <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    password <span class="type">varchar</span>(<span class="number">128</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这个长度的选择通常基于你的业务需求和预期数据长度。不过需要注意的是，指定长度并不会限制你在插入数据时输入的实际字符数，只是影响数据库内部分配的存储空间。</p>
<h2 id="为啥一般varchar都指定255"><a href="#为啥一般varchar都指定255" class="headerlink" title="为啥一般varchar都指定255"></a>为啥一般varchar都指定255</h2><p>在关系型数据库中，为 <code>VARCHAR</code> 字段指定长度是一个常见的做法，通常长度为 255。这是由于历史原因和一些实践经验所致。然而，这不是固定的规则，实际应用中需要根据需求进行选择。</p>
<p>以下是一些可能的原因，解释为什么一般会为 <code>VARCHAR</code> 字段指定长度为 255：</p>
<ol>
<li><p><strong>兼容性和迁移性</strong>: 一些数据库系统，特别是旧版本的数据库，可能对不带长度的 <code>VARCHAR</code> 字段定义行为不一致。指定一个合理的长度可以增加数据库迁移和兼容性方面的灵活性。</p>
</li>
<li><p><strong>数据存储的默认规定</strong>: 在某些数据库系统中，如果未指定 <code>VARCHAR</code> 的长度，默认长度可能是 1。为了避免这种情况，人们可能倾向于指定一个较大的长度。</p>
</li>
<li><p><strong>限制输入</strong>: 为 <code>VARCHAR</code> 字段指定长度可以帮助强制用户在输入时限制字符串的长度，防止输入过长的文本。</p>
</li>
<li><p><strong>避免过度的空间分配</strong>: 虽然 <code>VARCHAR</code> 是可变长度的，但在某些情况下，数据库可能会分配一些额外的存储空间来处理可变长度的数据。指定一个相对较小的长度可以帮助避免分配过多的空间。</p>
</li>
</ol>
<p>需要强调的是，长度为 255 并不是一定要遵循的规则，而是一个通用的选择。在实际设计中，你应该根据你的数据需求和数据库系统的特性来选择合适的长度。如果你知道你的数据很少会超过某个特定长度，你也可以选择更小的长度。最终，根据实际情况来权衡不同的因素，以便得出最适合你应用程序的决策。</p>
<h2 id="数据的完整性、安全性和查询需求"><a href="#数据的完整性、安全性和查询需求" class="headerlink" title="数据的完整性、安全性和查询需求"></a>数据的完整性、安全性和查询需求</h2><p>当设计数据库时，需要考虑以下几个方面，以确保数据的完整性、安全性和满足查询需求：</p>
<ol>
<li><p><strong>数据完整性</strong>：</p>
<ul>
<li><strong>主键和唯一性约束</strong>：确保每个记录都有唯一的标识，主键和唯一性约束可以防止重复数据。</li>
<li><strong>外键约束</strong>：建立表与表之间的关联，确保引用关系的数据是有效的。</li>
<li><strong>默认值</strong>：为字段设置默认值，确保即使没有显式提供值，也不会出现空值。</li>
<li><strong>检查约束</strong>：通过自定义规则限制字段值的范围和值，确保数据的有效性。</li>
</ul>
</li>
<li><p><strong>数据安全性</strong>：</p>
<ul>
<li><strong>敏感信息的加密和哈希</strong>：例如，用户密码应该以安全的方式存储，而不是明文存储。</li>
<li><strong>访问控制</strong>：限制谁可以访问数据库、哪些操作是允许的，通过角色和权限管理来实现。</li>
<li><strong>防止 SQL 注入</strong>：使用参数化查询或存储过程等来避免 SQL 注入攻击。</li>
<li><strong>数据备份和恢复</strong>：定期备份数据以防止数据丢失，同时有恢复计划来应对意外情况。</li>
</ul>
</li>
<li><p><strong>查询需求</strong>：</p>
<ul>
<li><strong>索引</strong>：根据查询需求创建适当的索引，以提高查询性能。</li>
<li><strong>优化查询语句</strong>：编写高效的查询语句，避免不必要的连接和子查询，优化数据库查询计划。</li>
<li><strong>视图和存储过程</strong>：创建视图以简化常见的查询操作，创建存储过程以执行复杂的操作。</li>
</ul>
</li>
<li><p><strong>容灾和可扩展性</strong>：</p>
<ul>
<li><strong>冗余和备份</strong>：为了防止硬件故障，数据中心故障等，需要考虑数据的冗余备份策略。</li>
<li><strong>分布式和集群</strong>：如果应用程序需要处理大量数据或高负载，考虑使用分布式数据库或集群来保证可扩展性和高可用性。</li>
</ul>
</li>
</ol>
<p>以上只是一些常见的考虑因素，实际应用中可能会有更多的具体需求和约束。在设计数据库时，需要根据应用程序的需求、数据的特性以及数据库系统的能力进行权衡和选择。同时，遵循最佳实践可以帮助你创建一个更安全、高效和可靠的数据库系统。</p>
<p>密码<br>处理用户密码是数据库设计中的一个关键安全问题。以下是一些处理密码的最佳实践：</p>
<ol>
<li><p><strong>密码哈希</strong>：绝对不要将密码明文存储在数据库中。相反，应该将密码使用哈希函数进行哈希处理，然后存储哈希值。常用的密码哈希算法包括 bcrypt、Argon2、PBKDF2 等。这样即使数据库泄露，攻击者也不会轻易获取用户的真实密码。</p>
</li>
<li><p><strong>加盐哈希</strong>：为了增加安全性，每个用户的密码都应该使用唯一的随机盐进行哈希处理。盐是一个随机字符串，它会与密码一起哈希，使得相同密码在不同用户之间也会产生不同的哈希值。</p>
</li>
<li><p><strong>迭代次数</strong>：哈希算法通常可以设置迭代次数，以增加破解密码的难度。更高的迭代次数会让密码破解更加困难，但也会增加服务器的计算开销。</p>
</li>
<li><p><strong>存储哈希和盐</strong>：在数据库中存储密码哈希值和相应的盐值。哈希和盐的存储通常是两个单独的字段。</p>
</li>
<li><p><strong>密码重置</strong>：实现安全的密码重置机制，可能通过发送电子邮件或其他身份验证方式。</p>
</li>
<li><p><strong>HTTPS</strong>：确保在用户输入密码时使用 HTTPS 来加密通信，以防止密码在传输过程中被截获。</p>
</li>
<li><p><strong>强密码策略</strong>：鼓励用户使用强密码，可能包括字母、数字、特殊字符的组合，并且要求密码长度达到一定的要求。</p>
</li>
<li><p><strong>两因素身份验证</strong>：为用户提供额外的安全性层，要求他们在登录时输入密码以外的另一因素，如验证码、手机短信等。</p>
</li>
</ol>
<p>总之，处理用户密码需要谨慎，因为密码安全是用户隐私的关键部分。采用最佳实践来保护用户密码，确保密码不容易被泄露或破解。</p>
<br>
---

<p>在绝大多数情况下，ER 图（实体关系图）中的表名首字母使用大写是一种常见的约定，但这并不是强制性的规则。</p>

                    
          </div>
          <footer>
            
              
                  
                      
                              <div class="clearfix"></div>
          </footer>
        </div>
</article>


<!-- 是否开启评论？ -->


  <article id="post-note-230814" class="h-entry post" itemprop="blogPost" itemscope
  itemtype="https://schema.org/BlogPosting">
  
        <div class="post-content">
          <header>
            
              <div class="icon"></div>
              <time class="dt-published" datetime="2023-08-14T11:01:25.000Z"><a
                  href="/2023/08/14/note-230814/">
                  2023-08-14
                </a></time>
              
                
  
    <h1 class="title"><a href="/2023/08/14/note-230814/">note_230814</a></h1>
  

          </header>
          <div class="e-content entry" itemprop="articleBody">
            
                  <span id="more"></span>
<h2 id="Column"><a href="#Column" class="headerlink" title="@Column"></a>@Column</h2><p>@Column 注解通常会处理数据库列名和Java实体类属性名之间的命名转换，从下划线分隔命名法（snake_case）转换为驼峰命名法（camelCase），或者根据具体的配置来进行命名映射。</p>
<h2 id="Cast"><a href="#Cast" class="headerlink" title="Cast"></a>Cast</h2><p>“Cast” 是计算机编程中的一个术语，用于表示将一个数据类型转换为另一个数据类型的操作。在不同的编程语言中，”cast” 可能有不同的称呼，例如类型转换、强制类型转换、类型转换操作等。</p>
<p>数据类型是编程语言中的一个重要概念，它定义了数据的存储方式和允许的操作。在某些情况下，你可能需要将一个数据值从一种数据类型转换为另一种数据类型，以便执行特定的计算或操作。这就是 “cast” 操作的用途。</p>
<p>以下是一个简单的示例，展示了 “cast” 的概念：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Java中，将一个整数转换为浮点数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">doubleValue</span> <span class="operator">=</span> (<span class="type">double</span>) intValue; <span class="comment">// 这里进行了一个强制类型转换，将整数转换为浮点数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在C++中，将一个浮点数转换为整数</span></span><br><span class="line"><span class="type">float</span> <span class="variable">floatValue</span> <span class="operator">=</span> <span class="number">3.14f</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> (<span class="type">int</span>) floatValue; <span class="comment">// 这里进行了一个强制类型转换，将浮点数转换为整数</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，数据类型之间的转换可能会导致数据精度丢失或错误，特别是在进行截断或舍入操作时。因此，在进行类型转换时，开发人员需要考虑数据范围和精度，并确保转换不会引起意外的问题。</p>
<h2 id="spring项目没加载出css"><a href="#spring项目没加载出css" class="headerlink" title="spring项目没加载出css"></a>spring项目没加载出css</h2><p>清除浏览器缓存：有时浏览器可能会缓存旧的CSS文件，导致新的样式无法加载。</p>
<h2 id="数据库中的-long-类型"><a href="#数据库中的-long-类型" class="headerlink" title="数据库中的 long 类型"></a>数据库中的 long 类型</h2><p>使用 “long” 数据类型来存储 “productid”（产品标识符）通常是基于数据的需求和范围考虑的决策。以下是一些考虑因素：</p>
<ol>
<li><p><strong>范围需求：</strong> “long” 数据类型通常支持更大的范围，可以存储比较大的整数值。如果您预计 “productid” 的值可能会很大，例如超过常规整数数据类型（如 “int”）所支持的范围，那么选择 “long” 可以确保您的数据库能够容纳这些值。</p>
</li>
<li><p><strong>未来扩展：</strong> 如果您的应用在未来可能会涉及到更大的数据集或更多的产品，使用 “long” 类型可以为未来的扩展性提供更多的余地。这样可以避免在后续需要扩展 “productid” 范围时进行数据库结构的变更。</p>
</li>
<li><p><strong>数据一致性：</strong> 如果 “productid” 被用作外键，而关联的表中使用了 “long” 数据类型，那么为了保持数据一致性，”productid” 也应该使用相同的数据类型。</p>
</li>
<li><p><strong>与其他系统的集成：</strong> 如果您的数据库需要与其他系统进行集成，并且这些系统使用了 “long” 数据类型来表示产品标识符，那么在数据库中也使用相同的数据类型可以简化数据交换和集成过程。</p>
</li>
</ol>
<p>需要注意的是，选择数据类型是根据项目需求和数据库设计的重要决策。虽然 “long” 数据类型可以支持更大的范围，但也可能会占用更多的存储空间。因此，在选择数据类型时，需要综合考虑数据的范围、存储需求以及系统的未来扩展性等因素。</p>
<hr>
<p>jar -xf lombok.jar 是解压 JAR 文件的命令，用于提取 JAR 文件中的内容。<br>java -jar lombok.jar 是运行 JAR 文件中的 Java 程序的命令，用于执行 JAR 文件中的可执行代码。</p>
<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>域名解析是将人类易于记忆的域名 （例如：<a target="_blank" rel="noopener" href="http://www.example.com)/">www.example.com）</a> 转换为计算机能够理解的IP地址（例如：192.168.1.1）。当您在浏览器中输入一个域名时，计算机需要知道如何连接到该域名对应的服务器，这就是通过域名解析来实现的。</p>
<p>域名解析的过程涉及到域名系统（Domain Name System，DNS），这是一个分布式的网络系统，用于将域名映射到IP地址以及其他与域名相关的信息。下面是域名解析的基本过程：</p>
<ol>
<li><p><strong>发起解析请求：</strong> 当您在浏览器中输入一个域名并按下回车键时，您的计算机会发起一个DNS解析请求，以获取与该域名相关的IP地址。</p>
</li>
<li><p><strong>本地域名服务器查询：</strong> 您的计算机首先会查询本地域名服务器，通常是由您的网络服务提供商分配的。如果本地服务器有该域名的缓存记录，它会返回相应的IP地址。</p>
</li>
<li><p><strong>递归解析过程：</strong> 如果本地服务器没有相关域名的缓存记录，它会向更高层次的域名服务器发出请求。这个过程会从顶级域名服务器（例如：.com、.org）开始，然后逐级向下查询，直到找到负责管理该域名的域名服务器。</p>
</li>
<li><p><strong>域名服务器返回IP地址：</strong> 域名服务器根据您的查询返回与域名相关的IP地址。这个IP地址可以是主机服务器的地址，该服务器存储着与该域名关联的网站或服务。</p>
</li>
<li><p><strong>计算机连接服务器：</strong> 一旦您的计算机获得了域名对应的IP地址，它就可以使用该IP地址建立与相应服务器的连接。这使得您能够在浏览器中访问该域名对应的网站或服务。</p>
</li>
</ol>
<h2 id="namesilo-com"><a href="#namesilo-com" class="headerlink" title="namesilo.com"></a>namesilo.com</h2><blockquote>
<p>在 namesilo.com 上购买域名却又在腾讯云上设置免费域名解析的可能原因：</p>
<ul>
<li>备用解析： 有些人认为使用多个域名解析服务可以提供备用的解析选项，以防止一个服务出现故障时可以快速切换到另一个服务。</li>
<li>地域分布： 一些大型域名解析服务提供商在全球各地都有服务器分布，这可以帮助加速不同地区用户的DNS解析请求。（墙？）</li>
</ul>
</blockquote>
<h3 id="HOSTNAMETYPEADDRESS-VALUEDISTANCE-PRIOTTLSERVICE"><a href="#HOSTNAMETYPEADDRESS-VALUEDISTANCE-PRIOTTLSERVICE" class="headerlink" title="HOSTNAME	TYPE	ADDRESS &#x2F; VALUE	DISTANCE&#x2F;PRIO	TTL	SERVICE"></a>HOSTNAME	TYPE	ADDRESS &#x2F; VALUE	DISTANCE&#x2F;PRIO	TTL	SERVICE</h3><p><img src="/assets/images/Snipaste_2023-08-14_19-11-06.png" alt="图图图：我只在namesilo上设置了域名解析" title="图"></p>
<p>在DNS（Domain Name System） </p>
<ol>
<li><p><strong>Hostname</strong>（主机名）：这是你想要设置DNS记录的域名部分。例如，如果你想要设置一个子域名记录，主机名可能是“www”、“blog”等。对于根域名记录，主机名通常为空。</p>
</li>
<li><p><strong>Type</strong>（类型）：这指定了DNS记录的类型。不同的记录类型对应不同的功能。一些常见的记录类型包括：</p>
<ul>
<li>A：将域名指向IPv4地址。</li>
<li>AAAA：将域名指向IPv6地址。</li>
<li>CNAME：将域名指向另一个域名。</li>
<li>MX：指定邮件服务器的优先级和地址。</li>
<li>TXT：存储任意文本信息。</li>
<li>SRV：指定服务的位置和优先级。</li>
</ul>
</li>
<li><p><strong>Address &#x2F; Value</strong>（地址&#x2F;值）：这取决于DNS记录的类型。对于A记录和AAAA记录，这将是一个IP地址；对于CNAME记录，这将是另一个域名；对于MX记录，这将是邮件服务器的地址。</p>
</li>
<li><p><strong>Distance&#x2F;PRIO</strong>（距离&#x2F;优先级）：这通常用于MX记录和SRV记录，用于指定优先级。对于MX记录，这表示邮件服务器的优先级，其中较小的数字表示较高的优先级。对于SRV记录，这表示服务的优先级，其中较小的数字同样表示较高的优先级。</p>
</li>
<li><p><strong>TTL</strong>（Time To Live，存活时间）：这是DNS记录在缓存中的存储时间，以秒为单位。它控制了缓存记录的过期时间，之后DNS解析器会重新获取最新的记录。</p>
</li>
<li><p><strong>Service</strong>（服务）：这通常用于SRV记录，表示提供特定服务的服务器的名称。例如，它可以是“_http”表示HTTP服务，或者是“_smtp”表示SMTP服务。</p>
</li>
</ol>
<p>需要注意的是，具体的字段和意义可能会因DNS记录类型和DNS服务的不同而有所不同。当你在配置DNS记录时，你需要根据所需的功能和上下文来正确填写这些字段。</p>
<h4 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h4><p>TTL（Time To Live）是DNS记录中的一个属性，指定了该记录在DNS缓存中的存储时间。它表示一个DNS记录在被存储在缓存中的时间长度，以秒为单位。当一个DNS查询请求被解析器发送到DNS服务器时，解析器会在缓存中存储从服务器返回的DNS记录，并在TTL时间到期后，将该记录从缓存中删除。</p>
<p>TTL的作用是控制DNS缓存中的记录的更新频率。较短的TTL会使记录更频繁地从服务器重新获取，这对于经常变化的记录（如DNS迁移或负载均衡设置）很有用。较长的TTL会减少对DNS服务器的查询请求，从而提高效率，但会导致在记录变更时，更新可能需要更长的时间。</p>
<p>例如，如果一个DNS记录的TTL被设置为3600秒（1小时），那么在解析器从DNS服务器获取该记录后，它会在1小时后尝试重新获取该记录。</p>
<p>要注意的是，TTL的实际行为可能因DNS解析器、缓存服务器和DNS记录类型等因素而有所不同。当你在配置DNS记录时，你可以设置TTL以适应你的需求。通常来说，较短的TTL对于频繁变更的记录更合适，较长的TTL适用于相对稳定的记录。</p>
<p>当你在设置DNS记录时，你会被要求提供TTL值，你可以根据你的需求设置合适的值。</p>
<h2 id="https-jutta-top-和-https-jutta-top"><a href="#https-jutta-top-和-https-jutta-top" class="headerlink" title="https://jutta.top/ 和 https://jutta.top"></a><a href="https://jutta.top/">https://jutta.top/</a> 和 <a href="https://jutta.top/">https://jutta.top</a></h2><p><code>https://jutta.top/</code> 和 <code>https://jutta.top</code> 看起来很相似，但在 URL 结构中确实有一个微小的区别，可能会影响网站的访问方式。</p>
<ol>
<li><p>**<code>https://jutta.top/</code>**：在这个 URL 中，斜杠 <code>/</code> 表示一个路径分隔符，指示浏览器访问的是域名 <code>jutta.top</code> 下的根目录。这是一种常见的 URL 结构，其中根目录可能包含网站的首页或其他内容。</p>
</li>
<li><p>**<code>https://jutta.top</code>**：在这个 URL 中，没有斜杠 <code>/</code>，这意味着浏览器将访问域名 <code>jutta.top</code> 的根目录，而不需要在域名后添加额外的路径。这通常会自动重定向到 <code>https://jutta.top/</code>，因为大多数网站会将没有斜杠的域名重定向到包含斜杠的路径。</p>
</li>
</ol>
<p>总结：这两个 URL 的实际效果可能是相同的，因为大多数网站会自动将没有斜杠的域名重定向到带斜杠的路径。但是，从 URL 结构的角度来看，它们稍微有些不同。最好的做法是使用 <code>https://jutta.top/</code>，因为这是标准的 URL 结构，可以避免可能的重定向问题。</p>
<p>百度的主要域名 <code>www.baidu.com</code> 以及其他许多网站都选择了将 URL 结尾设置为不带斜杠的版本。但这只是个人或组织的选择，不会对网站的功能产生影响。在大多数情况下，服务器会自动处理重定向，以确保访问的一致性。</p>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p>UML是“统一建模语言”（Unified Modeling Language）的缩写，它是一种用于软件系统设计、建模和文档化的标准化图形化语言。UML提供了一组图形符号和表示法，用于表示系统的结构、行为、交互和其他方面，从而帮助开发人员更清晰地理解和沟通关于软件系统的设计和功能。</p>
<h2 id="JSON、XML和YAML"><a href="#JSON、XML和YAML" class="headerlink" title="JSON、XML和YAML"></a>JSON、XML和YAML</h2><p>JSON、XML和YAML都是用于数据表示和交换的文本格式，但它们在语法、结构和用途上有一些不同。</p>
<p><strong>JSON 示例：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;book&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The Great Gatsby&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;F. Scott Fitzgerald&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;year&quot;</span><span class="punctuation">:</span> <span class="number">1925</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;genre&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Novel&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>JSON使用键值对表示数据，具有紧凑的语法，常用于Web应用程序和API中。</p>
<p><strong>XML 示例：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>The Great Gatsby<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>F. Scott Fitzgerald<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>1925<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">genre</span>&gt;</span>Novel<span class="tag">&lt;/<span class="name">genre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>XML使用标签和属性表示数据，具有较为灵活的结构，适用于复杂数据和结构化信息的表示。</p>
<p><strong>YAML 示例：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">book:</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">&quot;The Great Gatsby&quot;</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">&quot;F. Scott Fitzgerald&quot;</span></span><br><span class="line">  <span class="attr">year:</span> <span class="number">1925</span></span><br><span class="line">  <span class="attr">genre:</span> <span class="string">&quot;Novel&quot;</span></span><br></pre></td></tr></table></figure>

<p>YAML强调可读性和简洁性，适用于配置文件、数据存储和文档。</p>
<p>在选择使用哪种格式时，考虑以下因素：</p>
<ul>
<li>数据结构的复杂性：XML适用于复杂数据结构，JSON适用于相对简单的结构，YAML在中等复杂性场景下也表现良好。</li>
<li>可读性：YAML注重易读性，JSON相对于XML较为紧凑。</li>
<li>应用场景：JSON常用于Web应用程序和API，XML适用于复杂数据、配置文件等，YAML适用于配置和易读性要求较高的情况。</li>
</ul>
<p>在实际应用中，可以根据需求和团队偏好选择最合适的格式。</p>
<h2 id="yml和yaml"><a href="#yml和yaml" class="headerlink" title="yml和yaml"></a>yml和yaml</h2><p>YAML（YAML Ain’t Markup Language）是一种人类友好的数据序列化格式，用于配置文件、数据存储和文档。它的文件扩展名可以是<code>.yaml</code>或<code>.yml</code>，但是它们在语法和用法上是等价的，可以互相替换使用。<br>最初，YAML的扩展名是<code>.yaml</code>，但由于文件扩展名的长度可能会影响某些场景下的易用性，因此也允许使用<code>.yml</code>作为文件扩展名。实际上，<code>.yml</code>已经成为广泛使用的文件扩展名，因为它更短，更容易记忆。<br>无论你使用<code>.yaml</code>还是<code>.yml</code>，YAML的语法和用法都是相同的。它的主要目标是提供一种易于阅读和编辑的文本格式，适用于配置文件、数据传输、文档等场景。在大多数情况下，你可以根据自己的喜好和团队的偏好来选择使用<code>.yaml</code>或<code>.yml</code>作为文件扩展名。</p>
<h2 id="域名重定向或转发"><a href="#域名重定向或转发" class="headerlink" title="域名重定向或转发"></a>域名重定向或转发</h2><p>域名重定向或转发是在互联网上管理和引导流量的一种方法。这些技术允许你将一个域名的访问请求导向到另一个域名或URL。以下是一些常见的情况和理由，说明为什么需要域名重定向或转发：</p>
<ol>
<li><p><strong>更改域名或品牌</strong>：如果你的网站或业务更改了名称、品牌或域名，你可能希望旧域名的访问请求自动重定向到新的域名，以保持用户的访问和流量不受影响。</p>
</li>
<li><p><strong>多个域名指向同一站点</strong>：有时候你可能拥有多个域名，但想要将它们都指向同一个网站。通过域名重定向，你可以确保无论用户使用哪个域名访问，他们都会被引导到同一个网站。</p>
</li>
<li><p><strong>保护品牌</strong>：有些公司会注册与自己品牌或商标相似的域名，以防止其他人滥用。通过将这些域名设置为重定向到公司的主要网站，可以避免其他人误导或误用你的品牌。</p>
</li>
<li><p><strong>简化访问</strong>：有时候网站的URL可能很长或复杂，通过设置域名重定向，你可以创建一个简化的域名，更方便用户访问。</p>
</li>
<li><p><strong>推广活动</strong>：在广告活动、推广或特定活动期间，你可能希望创建一个短暂的域名或URL，然后将其重定向到特定页面，以便更容易分享和宣传。</p>
</li>
<li><p><strong>移动设备适配</strong>：你可能希望为移动设备用户提供一个短域名，以便更方便地访问移动友好的版本，而不是使用完整的域名。</p>
</li>
<li><p><strong>错误修正</strong>：有时用户可能会手动输入错误的域名，或者老版本的书签可能指向已更改的页面。通过设置重定向，你可以确保这些用户仍然能够找到正确的内容。</p>
</li>
</ol>
<p>总之，域名重定向或转发可以帮助你管理流量、维护品牌一致性、改善用户体验以及简化访问。然而，在设置重定向时，请确保了解其影响，避免错误配置，以免引发问题。</p>

                    
          </div>
          <footer>
            
              
                  
                      
                              <div class="clearfix"></div>
          </footer>
        </div>
</article>


<!-- 是否开启评论？ -->


  <article id="post-Week-1-of-AWS" class="h-entry post" itemprop="blogPost" itemscope
  itemtype="https://schema.org/BlogPosting">
  
        <div class="post-content">
          <header>
            
              <div class="icon"></div>
              <time class="dt-published" datetime="2023-08-12T12:05:14.000Z"><a
                  href="/2023/08/12/Week-1-of-AWS/">
                  2023-08-12
                </a></time>
              
                
  
    <h1 class="title"><a href="/2023/08/12/Week-1-of-AWS/">Week 1 of AWS</a></h1>
  

          </header>
          <div class="e-content entry" itemprop="articleBody">
            
              <h2 id="First-of-all-this-is-the-AWS-Guide-😁"><a href="#First-of-all-this-is-the-AWS-Guide-😁" class="headerlink" title="First of all, this is the AWS Guide 😁"></a>First of all, this is the <strong><a target="_blank" rel="noopener" href="https://d0.awsstatic.com/whitepapers/aws-overview.pdf">AWS Guide</a></strong> 😁</h2><h2 id="AWS-Cloud-Practitioner-Essentials-AWS-Training-and-Certification"><a href="#AWS-Cloud-Practitioner-Essentials-AWS-Training-and-Certification" class="headerlink" title="AWS Cloud Practitioner Essentials AWS Training and Certification"></a>AWS Cloud Practitioner Essentials AWS Training and Certification</h2>
                
          </div>
          <footer>
            
              
                <div class="alignleft">
                  <a href="/2023/08/12/Week-1-of-AWS/#more" class="more-link">
                    Read More
                  </a>
                </div>
                
                  
                      
                              <div class="clearfix"></div>
          </footer>
        </div>
</article>


<!-- 是否开启评论？ -->


  <article id="post-note-230809" class="h-entry post" itemprop="blogPost" itemscope
  itemtype="https://schema.org/BlogPosting">
  
        <div class="post-content">
          <header>
            
              <div class="icon"></div>
              <time class="dt-published" datetime="2023-08-08T16:00:00.000Z"><a
                  href="/2023/08/09/note-230809/">
                  2023-08-09
                </a></time>
              
                
  
    <h1 class="title"><a href="/2023/08/09/note-230809/">note_230809</a></h1>
  

          </header>
          <div class="e-content entry" itemprop="articleBody">
            
                  <span id="more"></span>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC是“Model-View-Controller”的缩写，它是一种常用的软件开发设计模式，用于将应用程序的关注点分离为三个相互连接的组件：</p>
<ol>
<li><p>模型（Model）：<br>模型代表应用程序的数据和业务逻辑。它处理数据的存储、检索和操作。模型封装了应用程序的数据和状态，并提供与之交互的方法。模型组件不直接与视图（用户界面）或控制器（用户输入）进行交互。</p>
</li>
<li><p>视图（View）：<br>视图代表应用程序的用户界面（UI）。它负责向用户显示数据，并呈现模型提供的信息。视图是被动的，不包含任何应用程序逻辑。它只关注如何将数据呈现给用户，以及如何显示用户的交互。</p>
</li>
<li><p>控制器（Controller）：<br>控制器充当模型和视图之间的中间层。它处理用户输入，对其进行处理，并相应地更新模型。当模型发生变化时，控制器会更新视图以反映这些变化。它负责管理模型和视图之间的数据流，根据用户的操作进行决策，并控制应用程序的整体行为。</p>
</li>
</ol>
<p>使用MVC模式的主要优势是它促进了关注点的分离，使代码库更易于维护和扩展。对用户界面（视图）的更改不会影响底层数据或业务逻辑（模型），反之亦然。这种模块化的方法增强了代码的可重用性，并促进了更有组织的开发过程。</p>
<p>MVC在各种编程语言和框架中广泛使用，用于构建Web应用程序、桌面应用程序和移动应用程序。一些使用MVC模式的流行框架包括Ruby on Rails（用于Ruby）、Django（用于Python）、ASP.NET MVC（用于.NET）和Spring（用于Java）。</p>
<h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><p>JavaBean是Java语言中的一个编程规范，用于创建可重用组件的标准方式。它是一种普通的Java类，遵循一组特定的约定和规则，以便在Java开发中使用它们更加方便。</p>
<p>JavaBean必须满足以下规范：</p>
<ol>
<li><p>公共类：JavaBean必须是一个公共类，即类声明使用<code>public</code>修饰符。</p>
</li>
<li><p>无参构造函数：JavaBean必须有一个无参数的公共构造函数（默认构造函数），这样可以通过该构造函数创建JavaBean的实例。</p>
</li>
<li><p>属性访问器（Getter和Setter方法）：JavaBean应该具有用于访问其属性的Getter和Setter方法。Getter方法用于获取属性的值，Setter方法用于设置属性的值。这样可以提供对JavaBean内部属性的封装和访问。</p>
</li>
<li><p>可序列化：JavaBean可以实现<code>java.io.Serializable</code>接口，从而允许其实例在网络上传输或保存在文件中。</p>
</li>
</ol>
<p>使用JavaBean的主要目的是促进代码的重用和提高代码的可读性。通过遵循JavaBean规范，可以创建符合标准的、易于使用的组件，这些组件可以在各种Java应用程序中使用，并且与其他JavaBean组件更加兼容。</p>
<p>例如，以下是一个简单的JavaBean示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter和Setter方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>Person</code>类符合JavaBean规范，具有公共类、无参构造函数和Getter&#x2F;Setter方法。同时，它还实现了<code>Serializable</code>接口，使得<code>Person</code>对象可以在网络上传输或进行序列化操作。</p>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>Servlet是Java编程语言的一个规范，用于在Web服务器上处理客户端请求和生成动态内容的组件。它是Java企业版（Java EE）中的核心技术之一，也可以在Java标准版（Java SE）中使用。</p>
<p>Servlet的主要目的是处理来自Web浏览器或其他HTTP客户端的请求，并根据这些请求生成动态的HTML内容。Servlet扮演了Web应用程序的控制器角色，可以接受HTTP请求并产生HTTP响应。</p>
<p>Servlet遵循以下规范：</p>
<ol>
<li><p>继承规范：一个Servlet类必须继承自<code>javax.servlet.http.HttpServlet</code>类或实现<code>javax.servlet.Servlet</code>接口。</p>
</li>
<li><p>URL映射：在Web应用程序的配置文件（通常是web.xml或使用注解）中，将Servlet映射到特定的URL模式，以便在接收到匹配的HTTP请求时调用相应的Servlet。</p>
</li>
<li><p>生命周期方法：Servlet具有一组生命周期方法，这些方法在Servlet的生命周期中被调用，包括初始化（init）、请求处理（service）和销毁（destroy）等阶段。</p>
</li>
<li><p>请求和响应处理：Servlet使用<code>HttpServletRequest</code>对象来接收HTTP请求数据，使用<code>HttpServletResponse</code>对象生成HTTP响应数据。通过这些对象，可以获取请求参数、处理请求数据，并生成HTML或其他内容作为响应发送回客户端。</p>
</li>
</ol>
<p>Servlet通常用于处理表单提交、登录认证、数据查询、数据保存等各种Web应用程序的业务逻辑。它们与Web容器（如Tomcat、Jetty等）紧密结合，Web容器负责管理Servlet的生命周期、多线程处理、请求分发等任务。</p>
<p>以下是一个简单的Servlet示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;&lt;html&gt;&lt;body&gt;Hello, World!&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>MyServlet</code>继承自<code>HttpServlet</code>，覆盖了<code>doGet</code>方法用于处理HTTP GET请求。当客户端发出HTTP GET请求并匹配到映射到<code>MyServlet</code>的URL模式时，<code>doGet</code>方法将会被调用，并向客户端发送”Hello, World!”的响应。</p>
<h2 id="Spring和Spring-Boot"><a href="#Spring和Spring-Boot" class="headerlink" title="Spring和Spring Boot"></a>Spring和Spring Boot</h2><p>Spring和Spring Boot都是Java平台上非常流行的开源框架，用于构建企业级应用程序。它们之间有一些区别，下面对它们进行简要的介绍：</p>
<h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring:"></a>Spring:</h4><p>Spring是一个轻量级的、模块化的Java开发框架，由Rod Johnson在2003年创建。它提供了大量的功能和库，用于解决企业级应用程序开发中的各种问题，如依赖注入（DI）、面向切面编程（AOP）、事务管理、数据访问、MVC框架等。Spring的目标是通过松耦合和可扩展的设计，提高Java应用程序的可维护性和可测试性。</p>
<p>Spring的特点：</p>
<ul>
<li>提供强大的IoC（控制反转）和DI（依赖注入）容器，使得对象的创建和管理更加灵活和易于测试。</li>
<li>AOP（面向切面编程）支持，允许在应用程序中解耦横切关注点（如日志记录、安全等）。</li>
<li>支持各种数据访问技术，包括JDBC、ORM（对象关系映射）框架（如Hibernate、JPA等）。</li>
<li>提供了Spring MVC框架，用于构建基于MVC模式的Web应用程序。</li>
</ul>
<h4 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot:"></a>Spring Boot:</h4><p>Spring Boot是由Pivotal团队于2014年推出的Spring项目的子项目。它是一个用于快速构建独立、生产级别的Spring应用程序的框架。Spring Boot旨在简化Spring应用程序的配置和部署，从而加快开发过程。它内置了许多常用的Spring组件和第三方库，并通过自动配置和约定优于配置的原则，使得开发者可以快速启动项目，并专注于业务逻辑的实现。</p>
<p>Spring Boot的特点：</p>
<ul>
<li>简化配置：Spring Boot自动配置大部分常用的Spring功能，减少了配置文件的编写工作。</li>
<li>内嵌服务器：Spring Boot可以内嵌Tomcat、Jetty或Undertow等Web服务器，使得应用程序可以直接以可执行的JAR包形式运行。</li>
<li>自动装配：Spring Boot根据项目的依赖关系自动装配各种组件，无需手动配置。</li>
<li>管理工具：Spring Boot提供了一组管理工具，用于监控和管理应用程序。</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>Spring是一个完整的企业级框架，提供了大量的功能和灵活性，但需要较多的配置。而Spring Boot则是在Spring基础上构建的快速开发框架，通过约定优于配置和自动化配置，使得开发更加简单快速。一般情况下，如果你希望快速构建一个简单的应用程序，可以选择使用Spring Boot；而如果你需要更多的定制化和灵活性，可以选择使用Spring。</p>
<h2 id="Spring和Spring-MVC"><a href="#Spring和Spring-MVC" class="headerlink" title="Spring和Spring MVC"></a>Spring和Spring MVC</h2><p>Spring和Spring MVC是相关但不同的概念，下面将它们进行详细的解释：</p>
<h3 id="Spring-1"><a href="#Spring-1" class="headerlink" title="Spring:"></a>Spring:</h3><p>Spring是一个综合性的Java企业级应用开发框架，提供了多个模块和功能，用于解决企业级应用程序的各种开发问题。它是一个轻量级、模块化的框架，以IoC（控制反转）和DI（依赖注入）为核心，通过将应用程序的各个组件解耦，提高了代码的可维护性和可测试性。</p>
<p>Spring提供了许多功能，包括：</p>
<ul>
<li>IoC容器：管理Java对象的生命周期，实现对象的创建、依赖注入和销毁等。</li>
<li>AOP（面向切面编程）：实现横切关注点的解耦，如事务管理、日志记录等。</li>
<li>JDBC和ORM（对象关系映射）：支持数据库访问，可以使用JDBC或整合第三方ORM框架如Hibernate。</li>
<li>事务管理：提供声明式的事务管理，简化了事务的编程工作。</li>
<li>集成测试支持：提供了对JUnit等测试框架的整合，使得测试变得更加方便。</li>
</ul>
<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC:"></a>Spring MVC:</h3><p>Spring MVC是Spring框架的一个模块，专注于构建基于MVC（Model-View-Controller）模式的Web应用程序。它在Spring框架的基础上提供了一个灵活且功能强大的MVC框架，用于处理Web请求和生成Web响应。</p>
<p>Spring MVC的特点和功能已在前面的回答中详细解释。简而言之，它主要用于处理Web层的逻辑，包括URL映射、请求处理、视图渲染等，帮助开发者更方便地构建Web应用程序。</p>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>Spring是一个全面的Java企业级开发框架，包含了许多模块和功能，可以用于构建各种类型的应用程序。而Spring MVC是Spring框架中的一个模块，专门用于构建Web应用程序，它提供了基于MVC模式的Web开发功能，帮助开发者更轻松地构建Web应用。</p>
<p>除了Spring核心框架和Spring MVC，Spring还包含许多其他模块，这些模块提供了广泛的功能，用于解决企业级应用开发中的不同问题。以下是一些常见的Spring框架其他模块：</p>
<ol>
<li><p>Spring Boot：<br>Spring Boot是Spring框架的一个子项目，旨在简化Spring应用程序的配置和部署。它通过自动配置和约定优于配置的原则，使得开发者可以更快速地启动和构建独立的、生产级别的Spring应用程序。Spring Boot内置了很多常用的功能和第三方库，使得开发过程更加简单。</p>
</li>
<li><p>Spring Data：<br>Spring Data是用于简化数据访问层的模块。它提供了统一的数据访问抽象层，支持多种数据存储技术，包括关系数据库、NoSQL数据库、Redis、Elasticsearch等。Spring Data可以减少数据访问代码的编写，提供了强大的查询功能和事务管理。</p>
</li>
<li><p>Spring Security：<br>Spring Security是用于身份认证和授权的模块。它提供了一套安全框架，用于保护应用程序的资源和控制用户的访问权限。Spring Security可以集成到Spring应用程序中，帮助开发者实现各种安全功能，如用户认证、访问控制、记住我、单点登录等。</p>
</li>
<li><p>Spring Batch：<br>Spring Batch是用于批处理处理的模块。它提供了处理大量数据的功能，支持复杂的批处理作业。Spring Batch可以用于数据清洗、数据转换、数据导入导出等数据处理任务。</p>
</li>
<li><p>Spring Cloud：<br>Spring Cloud是用于构建分布式系统的模块。它提供了一系列功能，用于解决微服务架构中的问题，如服务注册与发现、负载均衡、断路器、配置中心等。Spring Cloud可以与其他云计算和微服务技术（如Netflix的Eureka、Ribbon、Hystrix等）集成，帮助构建可伸缩、高可用的分布式应用。</p>
</li>
<li><p>Spring Integration：<br>Spring Integration是用于构建企业集成应用程序的模块。它提供了一组组件，用于实现不同系统之间的消息传递、事件驱动等集成方式。</p>
</li>
<li><p>Spring WebFlux：<br>Spring WebFlux是用于构建响应式Web应用程序的模块。它基于Reactor框架，提供了对响应式编程的支持，使得应用程序可以处理大量并发请求，以及异步非阻塞的方式进行处理。</p>
</li>
</ol>
<p>除了上述模块，Spring框架还包含其他一些模块，用于提供更多的功能和扩展，以满足不同应用场景的需求。Spring框架的模块化设计允许开发者根据需要选择和整合所需的功能，使得开发更加灵活和高效。</p>
<h5 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h5><p>单点登录（Single Sign-On，简称SSO）是一种身份认证和访问控制的技术，旨在让用户在一次登录后，可以访问多个相互信任的应用系统，而无需为每个应用系统单独进行登录认证。在SSO中，用户只需登录一次，然后就可以自由地访问所有受信任的应用系统，而无需再次输入用户名和密码。</p>
<p>传统的Web应用程序在不同的应用系统之间是独立的，用户需要为每个应用系统单独进行登录认证。这样会导致用户频繁地输入用户名和密码，增加了用户的负担，并且对于系统管理员来说，也增加了管理的复杂性。SSO技术通过引入一个单独的身份认证中心（也称为认证服务器），解决了这个问题。</p>
<p>SSO的基本工作流程如下：</p>
<ol>
<li>用户访问一个需要认证的应用系统。</li>
<li>应用系统发现用户未登录或登录已过期，将用户重定向到身份认证中心。</li>
<li>用户在身份认证中心输入用户名和密码进行登录。</li>
<li>身份认证中心验证用户的身份，如果验证通过，会颁发一个认证凭证（例如令牌或票据）。</li>
<li>应用系统将认证凭证返回给用户的浏览器。</li>
<li>用户的浏览器将认证凭证带回给应用系统。</li>
<li>应用系统验证认证凭证的有效性，如果有效，则将用户登录到应用系统。</li>
</ol>
<p>SSO的优点包括：</p>
<ol>
<li>用户友好：用户只需一次登录，即可访问所有受信任的应用系统，提高了用户体验。</li>
<li>安全性：通过专门的身份认证中心进行身份验证，可以提高认证的安全性，并减少密码泄露的风险。</li>
<li>简化管理：减少了系统管理员的管理工作，因为用户的身份认证集中管理在认证中心中。</li>
<li>集成性：允许不同平台和技术的应用系统进行集成，实现统一的登录认证。</li>
</ol>
<p>一些常见的SSO技术包括OAuth、OpenID Connect、SAML（Security Assertion Markup Language）等。这些技术可以根据具体需求和场景来选择使用。</p>
<p>OAuth、OpenID Connect和SAML都是身份认证和授权相关的协议或标准，用于实现单点登录（SSO）和安全访问控制。它们在不同的场景下有不同的应用，下面对它们进行简要的介绍：</p>
<ol>
<li>OAuth：<br>OAuth是一个开放标准的授权协议，旨在允许用户授权第三方应用访问受保护资源，而无需将用户的用户名和密码透露给第三方应用。OAuth通常用于授权访问用户在一个服务提供者（例如，Facebook、Google）上的资源，以便其他应用可以通过授权令牌（Access Token）访问这些资源。</li>
</ol>
<p>OAuth的主要角色包括：</p>
<ul>
<li>资源拥有者（Resource Owner）：即用户，拥有受保护资源。</li>
<li>客户端（Client）：即第三方应用，希望访问用户的资源。</li>
<li>授权服务器（Authorization Server）：负责颁发访问令牌给客户端。</li>
<li>资源服务器（Resource Server）：存储受保护的资源，验证令牌并提供资源给客户端。</li>
</ul>
<ol start="2">
<li>OpenID Connect：<br>OpenID Connect是建立在OAuth 2.0之上的一个身份认证协议。它扩展了OAuth 2.0，添加了身份认证的功能，使得OAuth 2.0可以用于用户身份认证和单点登录。OpenID Connect允许客户端在用户的授权下获取用户的身份信息，同时也可以使用OAuth 2.0的访问令牌来访问受保护的资源。</li>
</ol>
<p>OpenID Connect的主要角色和OAuth类似，但增加了一个身份提供者（Identity Provider）的角色，负责验证用户的身份和提供用户信息。</p>
<ol start="3">
<li>SAML（Security Assertion Markup Language）：<br>SAML是一种基于XML的开放标准，用于进行跨域身份认证和授权。它允许身份提供者（IdP）和服务提供者（SP）之间交换认证和授权信息，实现单点登录和单点登出。</li>
</ol>
<p>SAML的主要角色包括：</p>
<ul>
<li>身份提供者（Identity Provider，IdP）：负责验证用户的身份，并向服务提供者提供认证和授权信息。</li>
<li>服务提供者（Service Provider，SP）：提供受保护的资源，接受来自身份提供者的认证和授权信息。</li>
</ul>
<p>SAML通常用于企业环境中，例如企业内部的不同应用系统之间实现单点登录，或者企业与合作伙伴之间实现跨组织的身份认证和授权。</p>
<p>总结：<br>OAuth、OpenID Connect和SAML都是用于身份认证和授权的协议或标准，它们在不同的场景下有不同的应用。OAuth主要用于授权访问资源，OpenID Connect扩展了OAuth，用于用户身份认证和单点登录，而SAML则用于跨域身份认证和授权。开发者在选择使用时，需要根据具体的需求和场景来进行合适的选择。</p>
<h2 id="Spring-Tool-Suite"><a href="#Spring-Tool-Suite" class="headerlink" title="Spring Tool Suite"></a>Spring Tool Suite</h2><p>在 Eclipse 上下文中，”STS” 通常指的是 “Spring Tool Suite”。</p>
<p>Spring Tool Suite (STS) 是一个基于 Eclipse IDE 的开发环境，专门为 Spring Framework 和相关项目提供支持。它由 Pivotal（现为 VMware 的一部分）开发和维护。STS 为 Spring 开发人员提供了一套强大的工具，使他们能够更轻松地开发、调试和部署 Spring 应用程序。</p>
<p>STS 提供了许多功能，包括：</p>
<ol>
<li><p>Spring 项目模板：可快速创建基于 Spring 的应用程序骨架，包括 Spring Boot 项目、Spring MVC 项目等。</p>
</li>
<li><p>代码自动完成：能够识别 Spring 相关的代码，并提供智能代码补全和代码导航。</p>
</li>
<li><p>Spring Bean 图形化编辑器：可以可视化显示 Spring 应用程序的组件和依赖关系。</p>
</li>
<li><p>调试和测试：集成了 Spring 应用程序的调试和单元测试功能。</p>
</li>
<li><p>内置 Maven 和 Gradle 支持：允许您使用这些构建工具来管理项目。</p>
</li>
<li><p>Spring Boot Dashboard：可轻松运行和监视 Spring Boot 应用程序。</p>
</li>
</ol>
<p>请注意，STS 的功能和特性可能会随着版本的更新而改变，因此具体的功能可能会有所不同。如果您是 Spring 开发人员，STS 是一个非常有用的开发工具，可以提高您的开发效率和舒适度。</p>
<h2 id="https-mvnrepository-com-repos-central-和-https-search-maven-org"><a href="#https-mvnrepository-com-repos-central-和-https-search-maven-org" class="headerlink" title="https://mvnrepository.com/repos/central 和 https://search.maven.org/"></a><a target="_blank" rel="noopener" href="https://mvnrepository.com/repos/central">https://mvnrepository.com/repos/central</a> 和 <a target="_blank" rel="noopener" href="https://search.maven.org/">https://search.maven.org/</a></h2><p>这两个网站都是与 Maven Central（Maven 中央仓库）相关的站点，但它们的功能和目的有一些区别：</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://mvnrepository.com/repos/central%EF%BC%9A">https://mvnrepository.com/repos/central：</a><br>这个网站是 Maven Repository 的一个子站点，专门用于展示 Maven Central（Maven 中央仓库）中的库和依赖项。它提供了一个更友好和易于搜索的界面，供开发者浏览和查找 Maven Central 中的库和依赖项。您可以在此站点上搜索和浏览 Maven Central 中的各种 Java 库、框架和工具，并查看它们的最新版本和相关信息。</p>
<p>主要特点：</p>
<ul>
<li>提供直观的搜索和浏览界面，方便查找和发现 Maven Central 中的库。</li>
<li>提供库的详细信息，包括最新版本、依赖关系、文档链接等。</li>
<li>提供 Maven 依赖坐标，以便将库添加到您的项目中。</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://search.maven.org/%EF%BC%9A">https://search.maven.org/：</a><br>这个网站是 Maven 官方提供的用于搜索 Maven Central（Maven 中央仓库）中的库和依赖项的站点。它是 Maven 的官方搜索引擎，提供更高级的搜索功能和与 Maven Central 数据库同步的实时结果。</p>
<p>主要特点：</p>
<ul>
<li>官方的 Maven 搜索引擎，提供实时的 Maven Central 数据。</li>
<li>支持高级搜索选项，可以按关键字、坐标、版本等多个条件进行精确搜索。</li>
<li>提供直接的 Maven 依赖代码片段，方便将库添加到您的项目中。</li>
</ul>
</li>
</ol>
<p>综上所述，这两个网站都是用于搜索和查找 Maven Central 中的库和依赖项的工具，但 <a target="_blank" rel="noopener" href="https://mvnrepository.com/repos/central">https://mvnrepository.com/repos/central</a> 更侧重于提供更简单和直观的界面，供开发者快速查找和浏览库，而 <a target="_blank" rel="noopener" href="https://search.maven.org/">https://search.maven.org/</a> 则更专注于提供官方的高级搜索功能，以满足更复杂的搜索需求。您可以根据个人喜好和需求选择使用其中之一。<br>简单复制坐标添加到pom.xml中，使用这两个链接中的哪个都无所谓。这是因为两个链接都提供了相同的信息：Maven构件的坐标。坐标是在Maven项目中标识依赖项的唯一方式，它由groupId、artifactId和version组成。</p>
<h3 id="“Maven-POM-File”和”Snippets”"><a href="#“Maven-POM-File”和”Snippets”" class="headerlink" title="“Maven POM File”和”Snippets”"></a>“Maven POM File”和”Snippets”</h3><p>在 <a target="_blank" rel="noopener" href="https://central.sonatype.com/artifact/org.mybatis/mybatis/3.5.13">https://central.sonatype.com/artifact/org.mybatis/mybatis/3.5.13</a> 页面中，”Maven POM File”和”Snippets”之间的区别如下：</p>
<ol>
<li><p>Maven POM File（Maven项目对象模型文件）：<br>这是一个完整的Maven项目对象模型文件，通常称为pom.xml。POM文件是用于构建和管理Maven项目的核心文件。它包含项目的元数据，如项目的坐标、依赖项、插件、构建配置等。在这个链接中，”Maven POM File”将会提供您在Maven项目中使用MyBatis 3.5.13时所需的完整pom.xml文件。您可以直接将该文件复制到您的项目中，然后进行适当的调整以满足您的项目需求。</p>
</li>
<li><p>Snippets（代码片段）：<br>这里的”Snippets”是指一些代码片段或示例代码，而不是完整的POM文件。这些代码片段通常是针对某个特定用例或配置的小段代码，您可以将它们复制到您的项目中，以实现特定的功能或配置。在这个链接中，”Snippets”可能会提供一些在Maven项目中集成MyBatis 3.5.13的代码示例，比如如何添加依赖项或配置MyBatis。</p>
</li>
</ol>
<p>总的来说，”Maven POM File”提供了一个完整的、可用于构建整个项目的pom.xml文件，而”Snippets”提供了一些用于特定用途的代码片段。如果您需要将MyBatis 3.5.13集成到一个新的Maven项目中，您可以使用”Maven POM File”，如果您只需要一些特定的配置或示例代码，您可以查看”Snippets”部分。</p>
<h2 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h2><p>Thymeleaf是一种Java服务器端模板引擎，用于构建Web应用程序。它允许开发人员在服务器端生成HTML页面，并在渲染时将动态数据注入到HTML中。Thymeleaf的设计目标是将模板的可读性和有效性与自然的HTML模板语法结合在一起。</p>
<p>使用Thymeleaf，您可以在HTML模板中使用类似于普通HTML的标记，同时也可以插入表达式来动态地渲染内容。它与Spring Framework等Java Web开发框架密切结合，特别是与Spring Boot一起使用，这使得开发Web应用程序更加方便。</p>
<p>Thymeleaf的主要特点包括：</p>
<ol>
<li><p>自然的HTML模板语法：模板与普通HTML文件的区别非常小，这使得模板很容易编写和维护。</p>
</li>
<li><p>表达式语言：使用Thymeleaf的表达式语言，您可以在模板中插入动态内容，访问后端数据，并执行条件判断和迭代等操作。</p>
</li>
<li><p>可以在浏览器端进行渲染：与某些服务器端模板引擎不同，Thymeleaf支持在服务器端和客户端两个阶段进行渲染。这使得在浏览器端执行JavaScript时，页面已经包含了动态数据，从而提高了用户体验。</p>
</li>
<li><p>支持国际化：Thymeleaf具有内置的国际化支持，使得多语言应用程序的开发和管理更加便捷。</p>
</li>
</ol>
<p>总的来说，Thymeleaf是一个强大且易于使用的服务器端模板引擎，它在Java Web应用程序的开发中发挥着重要的作用。</p>
<h3 id="Thymeleaf和JSP"><a href="#Thymeleaf和JSP" class="headerlink" title="Thymeleaf和JSP"></a>Thymeleaf和JSP</h3><p>您的感觉是正确的，Thymeleaf和JSP（JavaServer Pages）在某些方面确实有一些相似之处。它们都是用于在服务器端生成动态HTML页面的技术，但也有一些重要的区别。</p>
<p>相似之处：</p>
<ol>
<li><p>动态HTML生成：Thymeleaf和JSP都允许在服务器端生成动态HTML页面。您可以在模板或JSP文件中嵌入Java代码和表达式，将动态数据注入到页面中。</p>
</li>
<li><p>集成Spring框架：Thymeleaf和JSP都可以与Spring Framework（尤其是Spring Boot）集成，使得在开发Java Web应用程序时更加方便。</p>
</li>
</ol>
<p>不同之处：</p>
<ol>
<li><p>语法：Thymeleaf和JSP有不同的语法。JSP使用特殊的标签（例如&lt;% %&gt;）来嵌入Java代码，而Thymeleaf使用自然的HTML标签和表达式，使得模板的可读性更好。</p>
</li>
<li><p>跨平台支持：JSP通常与Java Servlet容器一起使用，例如Tomcat。而Thymeleaf是一个独立的模板引擎，不仅可以与Java Servlet容器一起使用，还可以在其他环境中（例如Spring WebFlux）使用。</p>
</li>
<li><p>时机：JSP是在运行时动态地生成HTML，它使用Java编程语言处理数据并生成内容。Thymeleaf可以在运行时和服务器端预渲染之前进行处理，也可以在浏览器端通过JavaScript执行，根据具体的应用场景进行选择。</p>
</li>
<li><p>可读性：由于Thymeleaf使用自然的HTML标签，它的模板通常更易于阅读和理解，特别是对于前端开发人员来说，因为他们可以更容易地识别和理解HTML结构。</p>
</li>
</ol>
<p>总体而言，Thymeleaf提供了一种更加现代化和易于使用的模板引擎，尤其适合与Spring框架集成。而JSP在一些项目中可能仍然是一种常用的选择，特别是在传统的Java Web开发中。</p>
<h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>Java中的ORM代表对象关系映射(Object-Relational Mapping)，它是一种技术，用于在关系型数据库和面向对象编程语言（如Java）之间建立映射，使得数据库中的表与Java中的类、对象之间可以进行相互转换。这使得开发人员可以使用面向对象的方式来操作数据库，而不需要直接编写SQL查询语句。</p>
<p>以下是一些Java中常见的ORM框架：</p>
<ol>
<li><p>Hibernate：Hibernate是最为知名和广泛使用的Java ORM框架之一。它提供了强大的对象-数据库映射功能，允许开发人员通过配置文件或注解将Java类映射到数据库表，同时提供了查询语言（HQL）来执行数据库操作。</p>
</li>
<li><p>JPA（Java Persistence API）：JPA是一种Java的ORM标准规范，定义了一组API，使得开发人员可以通过注解或XML配置来实现对象-数据库映射。JPA本身只是规范，不是一个具体的实现，但许多ORM框架（如Hibernate、EclipseLink）都实现了JPA规范。</p>
</li>
<li><p>MyBatis：MyBatis是另一种流行的Java ORM框架，它采用XML配置文件来定义SQL映射，可以更精细地控制SQL语句的编写和执行。与Hibernate和JPA不同，MyBatis更加接近SQL，适用于需要更多控制的情况。</p>
</li>
<li><p>EclipseLink：EclipseLink也是一个实现了JPA规范的ORM框架，它提供了高性能和丰富的特性，适用于复杂的应用场景。</p>
</li>
</ol>
<p>ORM框架的使用可以大大简化数据库操作，提高开发效率，但在选择框架时需要考虑项目需求、性能要求和开发团队的熟悉程度。每个框架都有其特定的优点和适用范围，您可以根据具体情况选择最适合您项目的框架。</p>
<h2 id="DAO-和-Entity"><a href="#DAO-和-Entity" class="headerlink" title="DAO 和 Entity"></a>DAO 和 Entity</h2><p>“dao” 是指数据访问对象（Data Access Object），而 “entity” 是指实体对象，通常用于映射数据库表中的数据。</p>
<p>在 Spring 中，”DAO” 通常是一个用于执行数据库操作的接口或类，而 “Entity” 是一个用于映射数据库表结构的 Java 类。下面我会分别介绍它们的作用和一般的实现方式：</p>
<ol>
<li><p><strong>DAO（数据访问对象）</strong>：</p>
<ul>
<li>DAO 是用于访问数据库并执行 CRUD（创建、读取、更新、删除）操作的对象。</li>
<li>它将业务逻辑与底层数据库操作解耦，使得应用程序能够更容易维护和测试。</li>
<li>通常，DAO 包含了针对实体对象的持久化方法，如保存、更新、查询等。</li>
</ul>
<p>示例代码（基于 Spring Data JPA）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    User <span class="title function_">findByUsername</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>UserDao</code> 是一个 DAO 接口，继承了 Spring Data JPA 提供的 <code>JpaRepository</code> 接口，它会自动为 <code>User</code> 实体生成一些常用的数据库操作方法。</p>
</li>
<li><p><strong>Entity（实体）</strong>：</p>
<ul>
<li>Entity 是一个普通的 Java 类，通常用于映射数据库表的结构。每个 Entity 类对应数据库中的一个表。</li>
<li>Entity 类中的属性与表中的列相对应，使用注解进行映射。</li>
<li>通过实体类，可以进行数据库记录的创建、查询、更新和删除等操作。</li>
</ul>
<p>示例代码（基于 JPA 注解）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getters, setters, constructors...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>上述示例中的 <code>UserDao</code> 接口和 <code>User</code> 实体类演示了 Spring 中使用 DAO 和 Entity 的典型方式，特别是在使用 Spring Data JPA 进行数据库访问的情况下。不同的持久化技术可能会有不同的实现方式，但核心概念通常是相似的。根据您的具体需求和技术栈，可能会有一些细微的差异。</p>
<h2 id="Jakarta"><a href="#Jakarta" class="headerlink" title="Jakarta"></a>Jakarta</h2><p>import jakarta.persistence.Entity;<br>Jakarta 是一个用于构建企业级 Java 应用程序的开源软件平台和技术生态系统。它起源于 Java 企业版（Java EE）平台，但后来发展成为一个由 Eclipse 基金会主导的项目。Jakarta 项目的目标是在开放和协作的社区中继续发展和推进 Java 企业级技术。</p>
<p>在过去，Java EE 是一套用于开发企业级应用程序的标准，提供了许多特性，如 Servlet、JSP、EJB 等。然而，由于发展进程相对缓慢和对开源社区的限制，Java EE 的发展逐渐受到了批评。于是，Java EE 社区的一些成员选择创建 Jakarta 项目，以在更开放和快速的环境中推动企业级 Java 技术。</p>
<p>Jakarta 项目包括许多子项目，这些子项目涵盖了多个领域，如 Web 应用开发、持久性、消息传递、安全性等。其中一些子项目是：</p>
<ul>
<li>Jakarta Servlet：用于开发基于 Java 的 Web 应用程序的 API。</li>
<li>Jakarta Persistence：提供 Java 对象和数据库之间的持久化机制，类似于 JPA（Java Persistence API）。</li>
<li>Jakarta Messaging：用于消息传递和异步通信的 API。</li>
<li>Jakarta Security：处理应用程序的安全性和身份验证授权。</li>
<li>等等。</li>
</ul>
<p>总的来说，Jakarta 项目旨在推动 Java 在企业级应用开发中的创新，促进开源社区的参与和贡献，以满足不断变化的企业级应用需求。它是 Java 生态系统中一个重要的开源项目，为开发者提供了更多选择和灵活性。</p>
<h2 id="github的workflow和action"><a href="#github的workflow和action" class="headerlink" title="github的workflow和action"></a>github的workflow和action</h2><p>GitHub Actions 是 GitHub 提供的一项功能，用于自动化软件开发工作流程。Workflow 是一组定义在存储库中的自动化任务，这些任务可以在特定事件触发时自动执行。每个 Workflow 由一个或多个 Action 组成，这些 Action 是可重复使用的任务单元，用于执行各种操作，如构建、测试、部署等。</p>
<p>下面是有关 GitHub Workflow 和 Actions 的一些关键概念：</p>
<ol>
<li><p><strong>Workflow</strong>：</p>
<ul>
<li>Workflow 是一组指令，定义了在特定事件触发时自动执行的操作。</li>
<li>每个 Workflow 通常由一个或多个步骤（Steps）组成。</li>
<li>Workflow 文件以 <code>.yml</code> 格式定义，存储在存储库的 <code>.github/workflows</code> 目录下。</li>
</ul>
</li>
<li><p><strong>Action</strong>：</p>
<ul>
<li>Action 是一个独立的任务单元，用于执行特定操作，如构建、测试、发布等。</li>
<li>您可以自定义 Action，也可以使用其他用户或组织创建的公共 Action。</li>
<li>Actions 可以在 Workflow 中按顺序组成步骤，以创建复杂的自动化流程。</li>
</ul>
</li>
<li><p><strong>事件</strong>：</p>
<ul>
<li>事件是触发 Workflow 执行的原因，如推送代码、发起 Pull 请求、发布新版本等。</li>
<li>每个事件类型都可以触发不同的 Workflow，以便在特定事件发生时自动执行相应的操作。</li>
</ul>
</li>
<li><p><strong>工作流程示例</strong>：</p>
<ul>
<li>一个简单的工作流程可以包含一系列步骤，如构建代码、运行测试、部署到服务器等。</li>
<li>您可以通过在 <code>.github/workflows</code> 目录中创建一个 Workflow 文件来定义这些步骤。</li>
<li>Workflow 文件会包含事件、触发条件和具体的步骤配置。</li>
</ul>
</li>
</ol>
<p>下面是一个简单的 Workflow 示例，用于在代码推送时自动构建和测试项目：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">code</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">JDK</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-java@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">java-version:</span> <span class="string">&#x27;11&#x27;</span></span><br><span class="line">        </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">with</span> <span class="string">Maven</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">mvn</span> <span class="string">clean</span> <span class="string">install</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">Tests</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">mvn</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>

<p>上述示例中，Workflow 名称为 “Build and Test”，当在 <code>main</code> 分支上推送代码时会触发。工作流程包含一个 <code>build</code> 作业，其中定义了一系列步骤，包括检出代码、设置 Java 环境、构建代码和运行测试。</p>
<p>这只是 GitHub Workflow 和 Actions 的一个简单介绍。实际上，您可以创建更复杂和定制化的工作流程，根据您的项目需求自动化各种任务，从代码构建到部署等。GitHub Actions 可以大大简化开发和 CI&#x2F;CD 过程，并为团队提供高效的自动化工具。</p>
<h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p>前端中的 Canvas 是 HTML5 提供的一个元素，它可以用于在网页上绘制图形、图像和动画。Canvas 元素允许你使用 JavaScript 通过绘制 API 在一个矩形区域内绘制各种图形，从而创建交互性和动态性更强的网页内容。</p>
<p>Canvas 本质上是一个类似画布的区域，你可以在上面绘制各种元素，比如线条、形状、文本、图像等。它的工作方式是通过 JavaScript 脚本操作绘制 API 来绘制内容。你可以控制图形的属性，如颜色、线型、填充等，也可以实现动画、交互和视觉效果。</p>
<p>使用 Canvas 可以创建各种类型的应用，包括游戏、图表、图像编辑器、动画等。它的灵活性和强大性使得开发者可以实现许多复杂的前端交互和视觉效果。</p>
<p>以下是一个简单的示例，展示了如何在 Canvas 上绘制一个红色的矩形：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Canvas 示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取 Canvas 元素的引用</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myCanvas&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取绘制上下文</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> context = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 绘制一个红色的矩形</span></span></span><br><span class="line"><span class="language-javascript">        context.<span class="property">fillStyle</span> = <span class="string">&quot;red&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">150</span>, <span class="number">80</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>getContext(&quot;2d&quot;)</code> 方法获取了一个 2D 绘制上下文，通过设置 <code>fillStyle</code> 属性为 “red” 并使用 <code>fillRect()</code> 方法绘制了一个红色的矩形。</p>
<p>总之，Canvas 是前端开发中用于绘制图形和实现交互性的强大工具，通过 JavaScript 控制绘制 API，可以创建各种视觉效果和动态内容。</p>

                    
          </div>
          <footer>
            
              
                  
                      
                              <div class="clearfix"></div>
          </footer>
        </div>
</article>


<!-- 是否开启评论？ -->


  <article id="post-hello-world" class="h-entry post" itemprop="blogPost" itemscope
  itemtype="https://schema.org/BlogPosting">
  
        <div class="post-content">
          <header>
            
              <div class="icon"></div>
              <time class="dt-published" datetime="2023-08-06T16:27:26.518Z"><a
                  href="/2023/08/07/hello-world/">
                  2023-08-07
                </a></time>
              
                
  
    <h1 class="title"><a href="/2023/08/07/hello-world/">Hello World</a></h1>
  

          </header>
          <div class="e-content entry" itemprop="articleBody">
            
                  <span id="more"></span>
<p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

                    
          </div>
          <footer>
            
              
                  
                      
                              <div class="clearfix"></div>
          </footer>
        </div>
</article>


<!-- 是否开启评论？ -->



<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div>
      </div>
      <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="as_sitesearch" value="jutta.top">
  </form>
</div>


  
<div class="widget tag">
  <h3 class="title">Categories</h3>
  <ul class="entry">
  
    <li><a href="/categories/Front-End/">Front-End</a><small>1</small></li>
  
    <li><a href="/categories/Note/">Note</a><small>3</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/AI/">AI</a><small>3</small></li>
  
    <li><a href="/tags/AWS/">AWS</a><small>2</small></li>
  
    <li><a href="/tags/Hexo/">Hexo</a><small>1</small></li>
  
  </ul>
</div>

</aside>
      <div class="clearfix"></div>
    </div>
    <!-- 这里是改动过的 -->
    <div id="footer" class="inner">
      <p>IP: <span id="ipAddress"></span></p>
      <p>Language: <span id="browserLanguage"></span></p>
    </div>
    <footer id="footer" class="inner"><div class="alignleft">
  
    &copy; 2023
      Jutta
        
</div>
<div class="clearfix"></div></footer>

    
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

  </body>

</html>